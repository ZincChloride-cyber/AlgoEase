{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\n/**\r\n Utilities for manipulating multisig transaction blobs.\r\n */\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\n/**\r\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\r\n * @param txn - the actual transaction.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - ordered list of public keys in this multisig\r\n * @returns encoded multisig blob\r\n */\nexport function createMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}) {\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map(pk => ({\n    pk: Buffer.from(pk)\n  }));\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn = {\n    msig,\n    txn: txnForEncoding\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\r\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\r\n * @param txn - the actual transaction to sign.\r\n * @param rawSig - a Buffer raw signature of that transaction\r\n * @param myPk - a public key that corresponds with rawSig\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - ordered list of public keys in this multisig\r\n * @returns encoded multisig blob\r\n */\nfunction createMultisigTransactionWithSignature(txn, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map(pk => address.encodeAddress(pk))\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig);\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\r\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\r\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\r\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\r\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\r\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\r\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  signTxn(sk) {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\r\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\r\n   * encoded with msgpack as a typed array.\r\n   * @param version - multisig version\r\n   * @param threshold - multisig threshold\r\n   * @param pks - multisig public key list, order is important.\r\n   * @param sk - an Algorand secret key to sign with.\r\n   * @returns an encoded, partially signed multisig transaction.\r\n   */\n  partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk) {\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n  /**\r\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\r\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\r\n   * @param metadata - multisig metadata\r\n   * @param signerAddr - address of the signer\r\n   * @param signature - raw multisig signature\r\n   * @returns an encoded, partially signed multisig transaction.\r\n   */\n  partialSignWithMultisigSignature(metadata, signerAddr, signature) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: signature,\n      myPk: address.decodeAddress(signerAddr).publicKey\n    }, metadata);\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(txnForEnc) {\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n}\n/**\r\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\r\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\r\n * @returns typed array msg-pack encoded multisig txn\r\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();\n  const refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(subsig => subsig.pk)\n  };\n  const refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));\n  const newSubsigs = refSigTx.msig.subsig.map(sig => ({\n    ...sig\n  }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    const authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const signedTxn = {\n    msig,\n    txn: refSigTx.txn\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  let pk;\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\r\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\r\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\r\n * @param txn - object with either payment or key registration fields\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\r\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\r\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\r\n */\nexport function signMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob\n  };\n}\n/**\r\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\r\n * While we could derive public key preimagery from the partially-signed multisig transaction,\r\n * we ask the caller to pass it back in, to ensure they know what they are signing.\r\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param sk - Algorand secret key\r\n * @returns object containing txID, and blob representing encoded multisig txn\r\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\r\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\r\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\r\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param signerAddr - address of the signer\r\n * @param signature - raw multisig signature\r\n * @returns object containing txID, and blob representing encoded multisig txn\r\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, signerAddr, signature) {\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({\n    version,\n    threshold,\n    pks\n  }, signerAddr, signature);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\r\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - list of Algorand addresses\r\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs\n}) {\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","createMultisigTransaction","txn","version","threshold","addrs","pks","map","addr","decodeAddress","publicKey","subsigs","pk","from","msig","v","thr","subsig","txnForEncoding","get_obj_for_encoding","signedTxn","msigAddr","fromMultisigPreImg","encodeAddress","snd","sgnr","Uint8Array","encode","createMultisigTransactionWithSignature","rawSig","myPk","encodedMsig","decode","keyExist","forEach","i","bytesEqual","s","Error","MultisigTransaction","Transaction","addLease","addRekey","signTxn","sk","partialSignTxn","keyPairFromSecretKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","from_obj_for_encoding","txnForEnc","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","undefined","refPreImage","refMsigAddr","newSubsigs","sig","unisig","unisigAlgoTxn","authAddr","preimg","msgigAddr","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","verifiedCounter","verify","signMultisigTransaction","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","call","txnAlreadyBuilt","algoTxn","blob","toString","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","msigTxn","partialSignedBlob","appendSignRawMultisigSignature","multisigAddress"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\multisig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport * as nacl from './nacl/naclWrappers';\r\nimport * as address from './encoding/address';\r\nimport * as encoding from './encoding/encoding';\r\nimport * as txnBuilder from './transaction';\r\nimport * as utils from './utils/utils';\r\nimport AnyTransaction, { EncodedTransaction } from './types/transactions';\r\nimport { MultisigMetadata } from './types/multisig';\r\nimport {\r\n  EncodedMultisig,\r\n  EncodedSignedTransaction,\r\n} from './types/transactions/encoded';\r\n\r\n/**\r\n Utilities for manipulating multisig transaction blobs.\r\n */\r\n\r\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\r\n  'Not enough multisig transactions to merge. Need at least two';\r\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG =\r\n  'Cannot merge txs. txIDs differ';\r\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG =\r\n  'Cannot merge txs. Auth addrs differ';\r\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\r\n  'Cannot merge txs. Multisig preimages differ';\r\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\r\n  'Cannot merge txs. subsigs are mismatched.';\r\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\r\nexport const MULTISIG_NO_MUTATE_ERROR_MSG =\r\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\r\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\r\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\r\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG =\r\n  'Cannot add multisig signature. Signature is not of the correct length.';\r\n\r\ninterface MultisigOptions {\r\n  rawSig: Uint8Array;\r\n  myPk: Uint8Array;\r\n}\r\n\r\ninterface MultisigMetadataWithPks extends Omit<MultisigMetadata, 'addrs'> {\r\n  pks: Uint8Array[];\r\n}\r\n\r\n/**\r\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\r\n * @param txn - the actual transaction.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - ordered list of public keys in this multisig\r\n * @returns encoded multisig blob\r\n */\r\nexport function createMultisigTransaction(\r\n  txn: txnBuilder.Transaction,\r\n  { version, threshold, addrs }: MultisigMetadata\r\n) {\r\n  // construct the appendable multisigned transaction format\r\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\r\n  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));\r\n\r\n  const msig: EncodedMultisig = {\r\n    v: version,\r\n    thr: threshold,\r\n    subsig: subsigs,\r\n  };\r\n  const txnForEncoding = txn.get_obj_for_encoding();\r\n  const signedTxn: EncodedSignedTransaction = {\r\n    msig,\r\n    txn: txnForEncoding,\r\n  };\r\n\r\n  // if the address of this multisig is different from the transaction sender,\r\n  // we need to add the auth-addr field\r\n  const msigAddr = address.fromMultisigPreImg({\r\n    version,\r\n    threshold,\r\n    pks,\r\n  });\r\n  if (\r\n    address.encodeAddress(txnForEncoding.snd) !==\r\n    address.encodeAddress(msigAddr)\r\n  ) {\r\n    signedTxn.sgnr = Buffer.from(msigAddr);\r\n  }\r\n\r\n  return new Uint8Array(encoding.encode(signedTxn));\r\n}\r\n\r\n/**\r\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\r\n * @param txn - the actual transaction to sign.\r\n * @param rawSig - a Buffer raw signature of that transaction\r\n * @param myPk - a public key that corresponds with rawSig\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - ordered list of public keys in this multisig\r\n * @returns encoded multisig blob\r\n */\r\nfunction createMultisigTransactionWithSignature(\r\n  txn: txnBuilder.Transaction,\r\n  { rawSig, myPk }: MultisigOptions,\r\n  { version, threshold, pks }: MultisigMetadataWithPks\r\n) {\r\n  // Create an empty encoded multisig transaction\r\n  const encodedMsig = createMultisigTransaction(txn, {\r\n    version,\r\n    threshold,\r\n    addrs: pks.map((pk) => address.encodeAddress(pk)),\r\n  });\r\n  // note: this is not signed yet, but will be shortly\r\n  const signedTxn = encoding.decode(encodedMsig) as EncodedSignedTransaction;\r\n\r\n  let keyExist = false;\r\n  // append the multisig signature to the corresponding public key in the multisig blob\r\n  signedTxn.msig.subsig.forEach((subsig, i) => {\r\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\r\n      keyExist = true;\r\n      signedTxn.msig.subsig[i].s = rawSig;\r\n    }\r\n  });\r\n  if (keyExist === false) {\r\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\r\n  }\r\n\r\n  // if the address of this multisig is different from the transaction sender,\r\n  // we need to add the auth-addr field\r\n  const msigAddr = address.fromMultisigPreImg({\r\n    version,\r\n    threshold,\r\n    pks,\r\n  });\r\n  if (\r\n    address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)\r\n  ) {\r\n    signedTxn.sgnr = Buffer.from(msigAddr);\r\n  }\r\n\r\n  return new Uint8Array(encoding.encode(signedTxn));\r\n}\r\n\r\n/**\r\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\r\n */\r\nexport class MultisigTransaction extends txnBuilder.Transaction {\r\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\r\n  /**\r\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\r\n   */\r\n  addLease() {\r\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\r\n  }\r\n\r\n  /**\r\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\r\n   */\r\n  addRekey() {\r\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\r\n  }\r\n\r\n  /**\r\n   * Override inherited method to throw an error, as traditional signing is not allowed\r\n   */\r\n  signTxn(sk: Uint8Array): Uint8Array; // This overload ensures that the override has a compatible type definition with the parent method\r\n  signTxn(sk: any): any {\r\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\r\n  }\r\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\r\n\r\n  /**\r\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\r\n   * encoded with msgpack as a typed array.\r\n   * @param version - multisig version\r\n   * @param threshold - multisig threshold\r\n   * @param pks - multisig public key list, order is important.\r\n   * @param sk - an Algorand secret key to sign with.\r\n   * @returns an encoded, partially signed multisig transaction.\r\n   */\r\n  partialSignTxn(\r\n    { version, threshold, pks }: MultisigMetadataWithPks,\r\n    sk: Uint8Array\r\n  ) {\r\n    // get signature verifier\r\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\r\n    return createMultisigTransactionWithSignature(\r\n      this,\r\n      { rawSig: this.rawSignTxn(sk), myPk },\r\n      { version, threshold, pks }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\r\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\r\n   * @param metadata - multisig metadata\r\n   * @param signerAddr - address of the signer\r\n   * @param signature - raw multisig signature\r\n   * @returns an encoded, partially signed multisig transaction.\r\n   */\r\n  partialSignWithMultisigSignature(\r\n    metadata: MultisigMetadataWithPks,\r\n    signerAddr: string,\r\n    signature: Uint8Array\r\n  ) {\r\n    if (!nacl.isValidSignatureLength(signature.length)) {\r\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\r\n    }\r\n    return createMultisigTransactionWithSignature(\r\n      this,\r\n      {\r\n        rawSig: signature,\r\n        myPk: address.decodeAddress(signerAddr).publicKey,\r\n      },\r\n      metadata\r\n    );\r\n  }\r\n\r\n  // eslint-disable-next-line camelcase\r\n  static from_obj_for_encoding(\r\n    txnForEnc: EncodedTransaction\r\n  ): MultisigTransaction {\r\n    return super.from_obj_for_encoding(txnForEnc) as MultisigTransaction;\r\n  }\r\n}\r\n\r\n/**\r\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\r\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\r\n * @returns typed array msg-pack encoded multisig txn\r\n */\r\nexport function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]) {\r\n  if (multisigTxnBlobs.length < 2) {\r\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\r\n  }\r\n  const refSigTx = encoding.decode(\r\n    multisigTxnBlobs[0]\r\n  ) as EncodedSignedTransaction;\r\n  const refTxID = MultisigTransaction.from_obj_for_encoding(\r\n    refSigTx.txn\r\n  ).txID();\r\n  const refAuthAddr = refSigTx.sgnr\r\n    ? address.encodeAddress(refSigTx.sgnr)\r\n    : undefined;\r\n  const refPreImage = {\r\n    version: refSigTx.msig.v,\r\n    threshold: refSigTx.msig.thr,\r\n    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),\r\n  };\r\n  const refMsigAddr = address.encodeAddress(\r\n    address.fromMultisigPreImg(refPreImage)\r\n  );\r\n\r\n  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));\r\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\r\n    const unisig = encoding.decode(\r\n      multisigTxnBlobs[i]\r\n    ) as EncodedSignedTransaction;\r\n\r\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\r\n    if (unisigAlgoTxn.txID() !== refTxID) {\r\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\r\n    }\r\n\r\n    const authAddr = unisig.sgnr\r\n      ? address.encodeAddress(unisig.sgnr)\r\n      : undefined;\r\n    if (refAuthAddr !== authAddr) {\r\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\r\n    }\r\n\r\n    // check multisig has same preimage as reference\r\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\r\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\r\n    }\r\n    const preimg: MultisigMetadataWithPks = {\r\n      version: unisig.msig.v,\r\n      threshold: unisig.msig.thr,\r\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\r\n    };\r\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\r\n    if (refMsigAddr !== msgigAddr) {\r\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\r\n    }\r\n\r\n    // now, we can merge\r\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\r\n      if (!uniSubsig.s) return;\r\n      const current = newSubsigs[index];\r\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\r\n      // of Dec 2020) React overrides the buffer package with an older version that does\r\n      // not support Uint8Arrays in the comparison function. See this thread for more\r\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\r\n      if (\r\n        current.s &&\r\n        Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0\r\n      ) {\r\n        // mismatch\r\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\r\n      }\r\n      current.s = uniSubsig.s;\r\n    });\r\n  }\r\n  const msig: EncodedMultisig = {\r\n    v: refSigTx.msig.v,\r\n    thr: refSigTx.msig.thr,\r\n    subsig: newSubsigs,\r\n  };\r\n  const signedTxn: EncodedSignedTransaction = {\r\n    msig,\r\n    txn: refSigTx.txn,\r\n  };\r\n  if (typeof refAuthAddr !== 'undefined') {\r\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\r\n  }\r\n  return new Uint8Array(encoding.encode(signedTxn));\r\n}\r\n\r\nexport function verifyMultisig(\r\n  toBeVerified: Uint8Array,\r\n  msig: EncodedMultisig,\r\n  publicKey: Uint8Array\r\n) {\r\n  const version = msig.v;\r\n  const threshold = msig.thr;\r\n  const subsigs = msig.subsig;\r\n\r\n  const pks = subsigs.map((subsig) => subsig.pk);\r\n  if (msig.subsig.length < threshold) {\r\n    return false;\r\n  }\r\n\r\n  let pk: Uint8Array;\r\n  try {\r\n    pk = address.fromMultisigPreImg({ version, threshold, pks });\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n\r\n  if (!utils.arrayEqual(pk, publicKey)) {\r\n    return false;\r\n  }\r\n\r\n  let counter = 0;\r\n  for (const subsig of subsigs) {\r\n    if (subsig.s !== undefined) {\r\n      counter += 1;\r\n    }\r\n  }\r\n  if (counter < threshold) {\r\n    return false;\r\n  }\r\n\r\n  let verifiedCounter = 0;\r\n  for (const subsig of subsigs) {\r\n    if (subsig.s !== undefined) {\r\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\r\n        verifiedCounter += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (verifiedCounter < threshold) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\r\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\r\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\r\n * @param txn - object with either payment or key registration fields\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\r\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\r\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\r\n */\r\nexport function signMultisigTransaction(\r\n  txn: txnBuilder.TransactionLike,\r\n  { version, threshold, addrs }: MultisigMetadata,\r\n  sk: Uint8Array\r\n) {\r\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\r\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\r\n    version,\r\n    threshold,\r\n    addrs,\r\n  });\r\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    txn.from = expectedFromRaw;\r\n  }\r\n  // build pks for partialSign\r\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\r\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\r\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\r\n  let algoTxn: MultisigTransaction;\r\n  let blob: Uint8Array;\r\n  if (txnAlreadyBuilt) {\r\n    algoTxn = (txn as unknown) as MultisigTransaction;\r\n    blob = MultisigTransaction.prototype.partialSignTxn.call(\r\n      algoTxn,\r\n      { version, threshold, pks },\r\n      sk\r\n    );\r\n  } else {\r\n    algoTxn = new MultisigTransaction(txn as AnyTransaction);\r\n    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);\r\n  }\r\n  return {\r\n    txID: algoTxn.txID().toString(),\r\n    blob,\r\n  };\r\n}\r\n\r\n/**\r\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\r\n * While we could derive public key preimagery from the partially-signed multisig transaction,\r\n * we ask the caller to pass it back in, to ensure they know what they are signing.\r\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param sk - Algorand secret key\r\n * @returns object containing txID, and blob representing encoded multisig txn\r\n */\r\nexport function appendSignMultisigTransaction(\r\n  multisigTxnBlob: Uint8Array,\r\n  { version, threshold, addrs }: MultisigMetadata,\r\n  sk: Uint8Array\r\n) {\r\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\r\n  // obtain underlying txn, sign it, and merge it\r\n  const multisigTxObj = encoding.decode(\r\n    multisigTxnBlob\r\n  ) as EncodedSignedTransaction;\r\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\r\n  const partialSignedBlob = msigTxn.partialSignTxn(\r\n    { version, threshold, pks },\r\n    sk\r\n  );\r\n  return {\r\n    txID: msigTxn.txID().toString(),\r\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\r\n  };\r\n}\r\n\r\n/**\r\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\r\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\r\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\r\n * @param signerAddr - address of the signer\r\n * @param signature - raw multisig signature\r\n * @returns object containing txID, and blob representing encoded multisig txn\r\n */\r\nexport function appendSignRawMultisigSignature(\r\n  multisigTxnBlob: Uint8Array,\r\n  { version, threshold, addrs }: MultisigMetadata,\r\n  signerAddr: string,\r\n  signature: Uint8Array\r\n) {\r\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\r\n  // obtain underlying txn, sign it, and merge it\r\n  const multisigTxObj = encoding.decode(\r\n    multisigTxnBlob\r\n  ) as EncodedSignedTransaction;\r\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\r\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature(\r\n    { version, threshold, pks },\r\n    signerAddr,\r\n    signature\r\n  );\r\n  return {\r\n    txID: msigTxn.txID().toString(),\r\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\r\n  };\r\n}\r\n\r\n/**\r\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - list of Algorand addresses\r\n */\r\nexport function multisigAddress({\r\n  version,\r\n  threshold,\r\n  addrs,\r\n}: MultisigMetadata) {\r\n  return address.fromMultisigPreImgAddrs({ version, threshold, addrs });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}