{"ast":null,"code":"import { encodeUnsignedSimulateTransaction } from './transaction';\nimport { signLogicSigTransactionObject } from './logicsig';\nimport { signMultisigTransaction, mergeMultisigTransactions } from './multisig';\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided basic Account.\r\n */\nexport function makeBasicAccountTransactionSigner(account) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      signed.push(txnGroup[index].signTxn(account.sk));\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided LogicSigAccount.\r\n */\nexport function makeLogicSigAccountTransactionSigner(account) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      const {\n        blob\n      } = signLogicSigTransactionObject(txnGroup[index], account);\n      signed.push(blob);\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided Multisig account.\r\n * @param msig - The Multisig account metadata\r\n * @param sks - An array of private keys belonging to the msig which should sign the transactions.\r\n */\nexport function makeMultiSigAccountTransactionSigner(msig, sks) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      const txn = txnGroup[index];\n      const partialSigs = [];\n      for (const sk of sks) {\n        const {\n          blob\n        } = signMultisigTransaction(txn, msig, sk);\n        partialSigs.push(blob);\n      }\n      if (partialSigs.length > 1) {\n        signed.push(mergeMultisigTransactions(partialSigs));\n      } else {\n        signed.push(partialSigs[0]);\n      }\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\r\n * Create a makeEmptyTransactionSigner that does not specify any signer or\r\n * signing capabilities. This should only be used to simulate transactions.\r\n */\nexport function makeEmptyTransactionSigner() {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  return (txnGroup, indexesToSign) => {\n    const unsigned = [];\n    for (const index of indexesToSign) {\n      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));\n    }\n    return Promise.resolve(unsigned);\n  };\n}\n/**\r\n * Check if a value conforms to the TransactionWithSigner structure.\r\n * @param value - The value to check.\r\n * @returns True if an only if the value has the structure of a TransactionWithSigner.\r\n */\nexport function isTransactionWithSigner(value) {\n  return typeof value === 'object' && Object.keys(value).length === 2 && typeof value.txn === 'object' && typeof value.signer === 'function';\n}","map":{"version":3,"names":["encodeUnsignedSimulateTransaction","signLogicSigTransactionObject","signMultisigTransaction","mergeMultisigTransactions","makeBasicAccountTransactionSigner","account","txnGroup","indexesToSign","signed","index","push","signTxn","sk","Promise","resolve","makeLogicSigAccountTransactionSigner","blob","makeMultiSigAccountTransactionSigner","msig","sks","txn","partialSigs","length","makeEmptyTransactionSigner","unsigned","isTransactionWithSigner","value","Object","keys","signer"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\signer.ts"],"sourcesContent":["import { encodeUnsignedSimulateTransaction, Transaction } from './transaction';\r\nimport Account from './types/account';\r\nimport { LogicSigAccount, signLogicSigTransactionObject } from './logicsig';\r\nimport { MultisigMetadata } from './types/multisig';\r\nimport { signMultisigTransaction, mergeMultisigTransactions } from './multisig';\r\n\r\n/**\r\n * This type represents a function which can sign transactions from an atomic transaction group.\r\n * @param txnGroup - The atomic group containing transactions to be signed\r\n * @param indexesToSign - An array of indexes in the atomic transaction group that should be signed\r\n * @returns A promise which resolves an array of encoded signed transactions. The length of the\r\n *   array will be the same as the length of indexesToSign, and each index i in the array\r\n *   corresponds to the signed transaction from txnGroup[indexesToSign[i]]\r\n */\r\nexport type TransactionSigner = (\r\n  txnGroup: Transaction[],\r\n  indexesToSign: number[]\r\n) => Promise<Uint8Array[]>;\r\n\r\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided basic Account.\r\n */\r\nexport function makeBasicAccountTransactionSigner(\r\n  account: Account\r\n): TransactionSigner {\r\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\r\n    const signed: Uint8Array[] = [];\r\n\r\n    for (const index of indexesToSign) {\r\n      signed.push(txnGroup[index].signTxn(account.sk));\r\n    }\r\n\r\n    return Promise.resolve(signed);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided LogicSigAccount.\r\n */\r\nexport function makeLogicSigAccountTransactionSigner(\r\n  account: LogicSigAccount\r\n): TransactionSigner {\r\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\r\n    const signed: Uint8Array[] = [];\r\n\r\n    for (const index of indexesToSign) {\r\n      const { blob } = signLogicSigTransactionObject(txnGroup[index], account);\r\n      signed.push(blob);\r\n    }\r\n\r\n    return Promise.resolve(signed);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a TransactionSigner that can sign transactions for the provided Multisig account.\r\n * @param msig - The Multisig account metadata\r\n * @param sks - An array of private keys belonging to the msig which should sign the transactions.\r\n */\r\nexport function makeMultiSigAccountTransactionSigner(\r\n  msig: MultisigMetadata,\r\n  sks: Uint8Array[]\r\n): TransactionSigner {\r\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\r\n    const signed: Uint8Array[] = [];\r\n\r\n    for (const index of indexesToSign) {\r\n      const txn = txnGroup[index];\r\n      const partialSigs: Uint8Array[] = [];\r\n\r\n      for (const sk of sks) {\r\n        const { blob } = signMultisigTransaction(txn, msig, sk);\r\n        partialSigs.push(blob);\r\n      }\r\n\r\n      if (partialSigs.length > 1) {\r\n        signed.push(mergeMultisigTransactions(partialSigs));\r\n      } else {\r\n        signed.push(partialSigs[0]);\r\n      }\r\n    }\r\n\r\n    return Promise.resolve(signed);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a makeEmptyTransactionSigner that does not specify any signer or\r\n * signing capabilities. This should only be used to simulate transactions.\r\n */\r\nexport function makeEmptyTransactionSigner(): TransactionSigner {\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\r\n    const unsigned: Uint8Array[] = [];\r\n\r\n    for (const index of indexesToSign) {\r\n      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));\r\n    }\r\n\r\n    return Promise.resolve(unsigned);\r\n  };\r\n}\r\n\r\n/** Represents an unsigned transactions and a signer that can authorize that transaction. */\r\nexport interface TransactionWithSigner {\r\n  /** An unsigned transaction */\r\n  txn: Transaction;\r\n  /** A transaction signer that can authorize txn */\r\n  signer: TransactionSigner;\r\n}\r\n\r\n/**\r\n * Check if a value conforms to the TransactionWithSigner structure.\r\n * @param value - The value to check.\r\n * @returns True if an only if the value has the structure of a TransactionWithSigner.\r\n */\r\nexport function isTransactionWithSigner(\r\n  value: any\r\n): value is TransactionWithSigner {\r\n  return (\r\n    typeof value === 'object' &&\r\n    Object.keys(value).length === 2 &&\r\n    typeof value.txn === 'object' &&\r\n    typeof value.signer === 'function'\r\n  );\r\n}\r\n"],"mappings":"AAAA,SAASA,iCAAiC,QAAqB,eAAe;AAE9E,SAA0BC,6BAA6B,QAAQ,YAAY;AAE3E,SAASC,uBAAuB,EAAEC,yBAAyB,QAAQ,YAAY;AAe/E;;;AAGA,OAAM,SAAUC,iCAAiCA,CAC/CC,OAAgB;EAEhB,OAAO,CAACC,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjCC,MAAM,CAACE,IAAI,CAACJ,QAAQ,CAACG,KAAK,CAAC,CAACE,OAAO,CAACN,OAAO,CAACO,EAAE,CAAC,CAAC;;IAGlD,OAAOC,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;AAGA,OAAM,SAAUO,oCAAoCA,CAClDV,OAAwB;EAExB,OAAO,CAACC,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjC,MAAM;QAAES;MAAI,CAAE,GAAGf,6BAA6B,CAACK,QAAQ,CAACG,KAAK,CAAC,EAAEJ,OAAO,CAAC;MACxEG,MAAM,CAACE,IAAI,CAACM,IAAI,CAAC;;IAGnB,OAAOH,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;;;AAKA,OAAM,SAAUS,oCAAoCA,CAClDC,IAAsB,EACtBC,GAAiB;EAEjB,OAAO,CAACb,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjC,MAAMa,GAAG,GAAGd,QAAQ,CAACG,KAAK,CAAC;MAC3B,MAAMY,WAAW,GAAiB,EAAE;MAEpC,KAAK,MAAMT,EAAE,IAAIO,GAAG,EAAE;QACpB,MAAM;UAAEH;QAAI,CAAE,GAAGd,uBAAuB,CAACkB,GAAG,EAAEF,IAAI,EAAEN,EAAE,CAAC;QACvDS,WAAW,CAACX,IAAI,CAACM,IAAI,CAAC;;MAGxB,IAAIK,WAAW,CAACC,MAAM,GAAG,CAAC,EAAE;QAC1Bd,MAAM,CAACE,IAAI,CAACP,yBAAyB,CAACkB,WAAW,CAAC,CAAC;OACpD,MAAM;QACLb,MAAM,CAACE,IAAI,CAACW,WAAW,CAAC,CAAC,CAAC,CAAC;;;IAI/B,OAAOR,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;;AAIA,OAAM,SAAUe,0BAA0BA,CAAA;EACxC;EACA,OAAO,CAACjB,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMiB,QAAQ,GAAiB,EAAE;IAEjC,KAAK,MAAMf,KAAK,IAAIF,aAAa,EAAE;MACjCiB,QAAQ,CAACd,IAAI,CAACV,iCAAiC,CAACM,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC;;IAGnE,OAAOI,OAAO,CAACC,OAAO,CAACU,QAAQ,CAAC;EAClC,CAAC;AACH;AAUA;;;;;AAKA,OAAM,SAAUC,uBAAuBA,CACrCC,KAAU;EAEV,OACE,OAAOA,KAAK,KAAK,QAAQ,IACzBC,MAAM,CAACC,IAAI,CAACF,KAAK,CAAC,CAACJ,MAAM,KAAK,CAAC,IAC/B,OAAOI,KAAK,CAACN,GAAG,KAAK,QAAQ,IAC7B,OAAOM,KAAK,CAACG,MAAM,KAAK,UAAU;AAEtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}