{"ast":null,"code":"import { Buffer } from 'buffer';\nclass URLTokenBaseHTTPError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n/**\r\n * Implementation of BaseHTTPClient that uses a URL and a token\r\n * and make the REST queries using fetch.\r\n * This is the default implementation of BaseHTTPClient.\r\n */\nexport class URLTokenBaseHTTPClient {\n  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {\n    this.defaultHeaders = defaultHeaders;\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n  /**\r\n   * Compute the URL for a path relative to the instance's address\r\n   * @param relativePath - A path string\r\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\r\n   *   relativePath already has query parameters on it, the additional parameters defined here will\r\n   *   be added to the URL without modifying those (unless a key collision occurs).\r\n   * @returns A URL string\r\n   */\n  getURL(relativePath, query) {\n    let fixedRelativePath;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value);\n      }\n    }\n    return address.toString();\n  }\n  static formatFetchResponseHeaders(headers) {\n    const headersObj = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n  static async checkHttpError(res) {\n    if (res.ok) {\n      return;\n    }\n    let body = null;\n    let bodyErrorMessage = null;\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded = JSON.parse(Buffer.from(body).toString());\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n    throw new URLTokenBaseHTTPError(message, {\n      body,\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    });\n  }\n  static async formatFetchResponse(res) {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    };\n  }\n  async get(relativePath, query, requestHeaders = {}) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async post(relativePath, data, query, requestHeaders = {}) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async delete(relativePath, data, query, requestHeaders = {}) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}","map":{"version":3,"names":["Buffer","URLTokenBaseHTTPError","Error","constructor","message","response","name","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","fixedBaseServer","endsWith","baseServerURL","URL","toString","protocol","length","baseURL","getURL","relativePath","query","fixedRelativePath","startsWith","address","key","value","Object","entries","searchParams","set","formatFetchResponseHeaders","headers","headersObj","forEach","checkHttpError","res","ok","body","bodyErrorMessage","Uint8Array","arrayBuffer","decoded","JSON","parse","from","_","status","statusText","formatFetchResponse","get","requestHeaders","fetch","post","data","method","delete"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\client\\urlTokenBaseHTTPClient.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport {\r\n  BaseHTTPClient,\r\n  BaseHTTPClientResponse,\r\n  BaseHTTPClientError,\r\n  Query,\r\n} from './baseHTTPClient';\r\n\r\nexport interface AlgodTokenHeader {\r\n  'X-Algo-API-Token': string;\r\n}\r\n\r\nexport interface IndexerTokenHeader {\r\n  'X-Indexer-API-Token': string;\r\n}\r\n\r\nexport interface KMDTokenHeader {\r\n  'X-KMD-API-Token': string;\r\n}\r\n\r\nexport interface CustomTokenHeader {\r\n  [headerName: string]: string;\r\n}\r\n\r\nclass URLTokenBaseHTTPError extends Error implements BaseHTTPClientError {\r\n  constructor(message: string, public response: BaseHTTPClientResponse) {\r\n    super(message);\r\n    this.name = 'URLTokenBaseHTTPError';\r\n    this.response = response;\r\n  }\r\n}\r\n\r\nexport type TokenHeader =\r\n  | AlgodTokenHeader\r\n  | IndexerTokenHeader\r\n  | KMDTokenHeader\r\n  | CustomTokenHeader;\r\n\r\n/**\r\n * Implementation of BaseHTTPClient that uses a URL and a token\r\n * and make the REST queries using fetch.\r\n * This is the default implementation of BaseHTTPClient.\r\n */\r\nexport class URLTokenBaseHTTPClient implements BaseHTTPClient {\r\n  private readonly baseURL: URL;\r\n  private readonly tokenHeader: TokenHeader;\r\n\r\n  constructor(\r\n    tokenHeader: TokenHeader,\r\n    baseServer: string,\r\n    port?: string | number,\r\n    private defaultHeaders: Record<string, any> = {}\r\n  ) {\r\n    // Append a trailing slash so we can use relative paths. Without the trailing\r\n    // slash, the last path segment will be replaced by the relative path. See\r\n    // usage in `addressWithPath`.\r\n    const fixedBaseServer = baseServer.endsWith('/')\r\n      ? baseServer\r\n      : `${baseServer}/`;\r\n    const baseServerURL = new URL(fixedBaseServer);\r\n    if (typeof port !== 'undefined') {\r\n      baseServerURL.port = port.toString();\r\n    }\r\n\r\n    if (baseServerURL.protocol.length === 0) {\r\n      throw new Error('Invalid base server URL, protocol must be defined.');\r\n    }\r\n\r\n    this.baseURL = baseServerURL;\r\n    this.tokenHeader = tokenHeader;\r\n  }\r\n\r\n  /**\r\n   * Compute the URL for a path relative to the instance's address\r\n   * @param relativePath - A path string\r\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\r\n   *   relativePath already has query parameters on it, the additional parameters defined here will\r\n   *   be added to the URL without modifying those (unless a key collision occurs).\r\n   * @returns A URL string\r\n   */\r\n  private getURL(relativePath: string, query?: Query<string>): string {\r\n    let fixedRelativePath: string;\r\n    if (relativePath.startsWith('./')) {\r\n      fixedRelativePath = relativePath;\r\n    } else if (relativePath.startsWith('/')) {\r\n      fixedRelativePath = `.${relativePath}`;\r\n    } else {\r\n      fixedRelativePath = `./${relativePath}`;\r\n    }\r\n    const address = new URL(fixedRelativePath, this.baseURL);\r\n    if (query) {\r\n      for (const [key, value] of Object.entries(query)) {\r\n        address.searchParams.set(key, value);\r\n      }\r\n    }\r\n    return address.toString();\r\n  }\r\n\r\n  private static formatFetchResponseHeaders(\r\n    headers: Headers\r\n  ): Record<string, string> {\r\n    const headersObj: Record<string, string> = {};\r\n    headers.forEach((key, value) => {\r\n      headersObj[key] = value;\r\n    });\r\n    return headersObj;\r\n  }\r\n\r\n  private static async checkHttpError(res: Response) {\r\n    if (res.ok) {\r\n      return;\r\n    }\r\n\r\n    let body: Uint8Array | null = null;\r\n    let bodyErrorMessage: string | null = null;\r\n\r\n    try {\r\n      body = new Uint8Array(await res.arrayBuffer());\r\n      const decoded: Record<string, any> = JSON.parse(\r\n        Buffer.from(body).toString()\r\n      );\r\n      if (decoded.message) {\r\n        bodyErrorMessage = decoded.message;\r\n      }\r\n    } catch (_) {\r\n      // ignore any error that happened while we are parsing the error response\r\n    }\r\n\r\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\r\n    if (bodyErrorMessage) {\r\n      message += `: ${bodyErrorMessage}`;\r\n    }\r\n\r\n    throw new URLTokenBaseHTTPError(message, {\r\n      body,\r\n      status: res.status,\r\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\r\n    });\r\n  }\r\n\r\n  private static async formatFetchResponse(\r\n    res: Response\r\n  ): Promise<BaseHTTPClientResponse> {\r\n    await this.checkHttpError(res);\r\n    return {\r\n      body: new Uint8Array(await res.arrayBuffer()),\r\n      status: res.status,\r\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\r\n    };\r\n  }\r\n\r\n  async get(\r\n    relativePath: string,\r\n    query?: Query<string>,\r\n    requestHeaders: Record<string, string> = {}\r\n  ): Promise<BaseHTTPClientResponse> {\r\n    // Expand headers for use in fetch\r\n    const headers = {\r\n      ...this.tokenHeader,\r\n      ...this.defaultHeaders,\r\n      ...requestHeaders,\r\n    };\r\n\r\n    const res = await fetch(this.getURL(relativePath, query), {\r\n      headers,\r\n    });\r\n\r\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\r\n  }\r\n\r\n  async post(\r\n    relativePath: string,\r\n    data: Uint8Array,\r\n    query?: Query<string>,\r\n    requestHeaders: Record<string, string> = {}\r\n  ): Promise<BaseHTTPClientResponse> {\r\n    // Expand headers for use in fetch\r\n    const headers = {\r\n      ...this.tokenHeader,\r\n      ...this.defaultHeaders,\r\n      ...requestHeaders,\r\n    };\r\n\r\n    const res = await fetch(this.getURL(relativePath, query), {\r\n      method: 'POST',\r\n      body: data,\r\n      headers,\r\n    });\r\n\r\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\r\n  }\r\n\r\n  async delete(\r\n    relativePath: string,\r\n    data: Uint8Array,\r\n    query?: Query<string>,\r\n    requestHeaders: Record<string, string> = {}\r\n  ): Promise<BaseHTTPClientResponse> {\r\n    // Expand headers for use in fetch\r\n    const headers = {\r\n      ...this.tokenHeader,\r\n      ...this.defaultHeaders,\r\n      ...requestHeaders,\r\n    };\r\n\r\n    const res = await fetch(this.getURL(relativePath, query), {\r\n      method: 'DELETE',\r\n      body: data,\r\n      headers,\r\n    });\r\n\r\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}