{"ast":null,"code":"// Smart Contract Utilities for AlgoEase\nimport algosdk from 'algosdk/dist/browser/algosdk.min.js';\n\n// Contract configuration\nconst CONTRACT_CONFIG = {\n  // These will be set after contract deployment\n  appId: parseInt(process.env.REACT_APP_CONTRACT_APP_ID) || 748433709,\n  // TestNet configuration\n  algodClient: new algosdk.Algodv2('', process.env.REACT_APP_ALGOD_URL || 'https://testnet-api.algonode.cloud', ''),\n  indexerClient: new algosdk.Indexer('', process.env.REACT_APP_INDEXER_URL || 'https://testnet-idx.algonode.cloud', '')\n};\n\n// Contract method constants\nexport const CONTRACT_METHODS = {\n  CREATE_BOUNTY: 'create_bounty',\n  ACCEPT_BOUNTY: 'accept_bounty',\n  APPROVE_BOUNTY: 'approve_bounty',\n  CLAIM_BOUNTY: 'claim',\n  REFUND_BOUNTY: 'refund',\n  AUTO_REFUND: 'auto_refund',\n  GET_BOUNTY: 'get_bounty'\n};\n\n// Status constants matching the smart contract\nexport const BOUNTY_STATUS = {\n  OPEN: 0,\n  ACCEPTED: 1,\n  APPROVED: 2,\n  CLAIMED: 3,\n  REFUNDED: 4\n};\n\n// Global state keys from the contract\nexport const GLOBAL_STATE_KEYS = {\n  BOUNTY_COUNT: 'bounty_count',\n  CLIENT_ADDR: 'client_addr',\n  FREELANCER_ADDR: 'freelancer_addr',\n  AMOUNT: 'amount',\n  DEADLINE: 'deadline',\n  STATUS: 'status',\n  TASK_DESCRIPTION: 'task_desc',\n  VERIFIER_ADDR: 'verifier_addr'\n};\nclass ContractUtils {\n  constructor() {\n    this.algodClient = CONTRACT_CONFIG.algodClient;\n    this.indexerClient = CONTRACT_CONFIG.indexerClient;\n    this.appId = CONTRACT_CONFIG.appId;\n  }\n\n  // Set contract app ID after deployment\n  setAppId(appId) {\n    this.appId = parseInt(appId);\n  }\n\n  // Get current contract app ID\n  getAppId() {\n    return this.appId;\n  }\n\n  // Get suggested transaction parameters\n  async getSuggestedParams() {\n    try {\n      const params = await this.algodClient.getTransactionParams().do();\n      return params;\n    } catch (error) {\n      console.error('Failed to get transaction parameters:', error);\n      throw error;\n    }\n  }\n\n  // Create application call transaction\n  async createAppCallTransaction(sender, method, args = [], accounts = [], note = '') {\n    if (!this.appId) {\n      throw new Error('Contract app ID not set. Please deploy the contract first.');\n    }\n    console.log('Creating app call transaction:');\n    console.log('  - App ID:', this.appId);\n    console.log('  - Method:', method);\n    console.log('  - Sender:', sender);\n    console.log('  - Accounts array:', accounts);\n    console.log('  - Accounts length:', accounts.length);\n    const suggestedParams = await this.getSuggestedParams();\n    const appArgs = [new Uint8Array(new TextEncoder().encode(method))];\n    args.forEach(arg => {\n      if (typeof arg === 'string') {\n        appArgs.push(new Uint8Array(new TextEncoder().encode(arg)));\n      } else if (typeof arg === 'number') {\n        appArgs.push(algosdk.encodeUint64(arg));\n      } else {\n        appArgs.push(arg);\n      }\n    });\n    const txn = algosdk.makeApplicationCallTxnFromObject({\n      from: sender,\n      appIndex: this.appId,\n      onComplete: algosdk.OnApplicationComplete.NoOpOC,\n      suggestedParams,\n      appArgs,\n      accounts,\n      note: note ? new Uint8Array(new TextEncoder().encode(note)) : undefined\n    });\n    return txn;\n  }\n\n  // Create payment transaction\n  async createPaymentTransaction(sender, receiver, amount, note = '') {\n    const suggestedParams = await this.getSuggestedParams();\n    const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n      from: sender,\n      to: receiver,\n      amount: Math.round(amount * 1000000),\n      // Convert ALGO to microALGO\n      suggestedParams,\n      note: note ? new Uint8Array(new TextEncoder().encode(note)) : undefined\n    });\n    return txn;\n  }\n\n  // Create bounty on smart contract\n  async createBounty(sender, amount, deadline, taskDescription, verifierAddress) {\n    try {\n      // Validate and ensure verifierAddress is set\n      if (!verifierAddress || verifierAddress.trim() === '') {\n        verifierAddress = sender; // Use sender as verifier if not specified\n      }\n      console.log('Creating bounty with verifier:', verifierAddress);\n\n      // Convert deadline to timestamp\n      const deadlineTimestamp = Math.floor(new Date(deadline).getTime() / 1000);\n\n      // Validate deadline is in the future\n      const now = Math.floor(Date.now() / 1000);\n      if (deadlineTimestamp <= now) {\n        throw new Error('Deadline must be in the future');\n      }\n\n      // Convert amount to microALGO\n      const amountMicroAlgo = Math.round(amount * 1000000);\n\n      // Create payment transaction to send funds to contract (must be first)\n      const paymentTxn = await this.createPaymentTransaction(sender, await this.getContractAddress(), amount,\n      // Amount in ALGO (function will convert to microALGO)\n      'AlgoEase: Bounty Payment');\n\n      // Create the application call transaction (must be second)\n      // IMPORTANT: accounts array must not be empty - pass verifierAddress\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.CREATE_BOUNTY, [amountMicroAlgo, deadlineTimestamp, taskDescription], [verifierAddress],\n      // This makes Txn.accounts.length() = 2 (sender + verifier)\n      'AlgoEase: Create Bounty');\n\n      // Assign group ID to transactions\n      algosdk.assignGroupID([paymentTxn, appCallTxn]);\n      return [paymentTxn, appCallTxn];\n    } catch (error) {\n      console.error('Failed to create bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Accept bounty\n  async acceptBounty(sender) {\n    try {\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.ACCEPT_BOUNTY, [], [], 'AlgoEase: Accept Bounty');\n      return appCallTxn;\n    } catch (error) {\n      console.error('Failed to create accept bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Approve bounty (verifier only)\n  async approveBounty(sender) {\n    try {\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.APPROVE_BOUNTY, [], [], 'AlgoEase: Approve Bounty');\n      return appCallTxn;\n    } catch (error) {\n      console.error('Failed to create approve bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Claim bounty payment\n  async claimBounty(sender) {\n    try {\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.CLAIM_BOUNTY, [], [], 'AlgoEase: Claim Bounty');\n      return appCallTxn;\n    } catch (error) {\n      console.error('Failed to create claim bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Refund bounty (manual refund by client or verifier)\n  async refundBounty(sender) {\n    try {\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.REFUND_BOUNTY, [], [], 'AlgoEase: Refund Bounty');\n      return appCallTxn;\n    } catch (error) {\n      console.error('Failed to create refund bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Auto refund bounty (when deadline has passed)\n  async autoRefundBounty(sender) {\n    try {\n      const appCallTxn = await this.createAppCallTransaction(sender, CONTRACT_METHODS.AUTO_REFUND, [], [], 'AlgoEase: Auto Refund Bounty');\n      return appCallTxn;\n    } catch (error) {\n      console.error('Failed to create auto refund bounty transaction:', error);\n      throw error;\n    }\n  }\n\n  // Get contract address\n  async getContractAddress() {\n    if (!this.appId) {\n      throw new Error('Contract app ID not set');\n    }\n    try {\n      // Calculate the application address from the app ID\n      // This is the address where the smart contract funds are stored\n      const appAddress = algosdk.getApplicationAddress(this.appId);\n      return appAddress;\n    } catch (error) {\n      console.error('Failed to get contract address:', error);\n      throw error;\n    }\n  }\n\n  // Get contract state\n  async getContractState() {\n    if (!this.appId) {\n      throw new Error('Contract app ID not set');\n    }\n    try {\n      const appInfo = await this.algodClient.getApplicationByID(this.appId).do();\n      const globalState = appInfo.params['global-state'] || [];\n\n      // Parse global state\n      const parsedState = {};\n      globalState.forEach(item => {\n        const key = atob(item.key); // Decode base64 to string\n        const value = item.value;\n        if (value.type === 1) {\n          // uint64\n          parsedState[key] = value.uint;\n        } else if (value.type === 2) {\n          // bytes\n          parsedState[key] = atob(value.bytes); // Decode base64 to string\n        }\n      });\n      return parsedState;\n    } catch (error) {\n      console.error('Failed to get contract state:', error);\n      throw error;\n    }\n  }\n\n  // Get current bounty information\n  async getCurrentBounty() {\n    try {\n      const state = await this.getContractState();\n      if (!state[GLOBAL_STATE_KEYS.BOUNTY_COUNT] || state[GLOBAL_STATE_KEYS.BOUNTY_COUNT] === 0) {\n        return null;\n      }\n      return {\n        bountyCount: state[GLOBAL_STATE_KEYS.BOUNTY_COUNT],\n        clientAddress: state[GLOBAL_STATE_KEYS.CLIENT_ADDR],\n        freelancerAddress: state[GLOBAL_STATE_KEYS.FREELANCER_ADDR],\n        amount: state[GLOBAL_STATE_KEYS.AMOUNT] / 1000000,\n        // Convert from microALGO to ALGO\n        deadline: new Date(state[GLOBAL_STATE_KEYS.DEADLINE] * 1000),\n        status: state[GLOBAL_STATE_KEYS.STATUS],\n        taskDescription: state[GLOBAL_STATE_KEYS.TASK_DESCRIPTION],\n        verifierAddress: state[GLOBAL_STATE_KEYS.VERIFIER_ADDR]\n      };\n    } catch (error) {\n      console.error('Failed to get current bounty:', error);\n      throw error;\n    }\n  }\n\n  // Check if user can perform action\n  canPerformAction(userAddress, action, bountyInfo) {\n    if (!bountyInfo) return false;\n    switch (action) {\n      case 'accept':\n        return bountyInfo.status === BOUNTY_STATUS.OPEN && userAddress !== bountyInfo.clientAddress;\n      case 'approve':\n        return bountyInfo.status === BOUNTY_STATUS.ACCEPTED && userAddress === bountyInfo.verifierAddress;\n      case 'claim':\n        return bountyInfo.status === BOUNTY_STATUS.APPROVED && userAddress === bountyInfo.freelancerAddress;\n      case 'refund':\n        return (bountyInfo.status === BOUNTY_STATUS.OPEN || bountyInfo.status === BOUNTY_STATUS.ACCEPTED) && (userAddress === bountyInfo.clientAddress || userAddress === bountyInfo.verifierAddress);\n      case 'auto_refund':\n        return (bountyInfo.status === BOUNTY_STATUS.OPEN || bountyInfo.status === BOUNTY_STATUS.ACCEPTED) && Date.now() / 1000 > bountyInfo.deadline.getTime() / 1000;\n      default:\n        return false;\n    }\n  }\n\n  // Get status name from status code\n  getStatusName(statusCode) {\n    switch (statusCode) {\n      case BOUNTY_STATUS.OPEN:\n        return 'open';\n      case BOUNTY_STATUS.ACCEPTED:\n        return 'accepted';\n      case BOUNTY_STATUS.APPROVED:\n        return 'approved';\n      case BOUNTY_STATUS.CLAIMED:\n        return 'claimed';\n      case BOUNTY_STATUS.REFUNDED:\n        return 'refunded';\n      default:\n        return 'unknown';\n    }\n  }\n\n  // Wait for transaction confirmation\n  async waitForConfirmation(txId, timeout = 10000) {\n    try {\n      const confirmedTxn = await algosdk.waitForConfirmation(this.algodClient, txId, timeout);\n      return confirmedTxn;\n    } catch (error) {\n      console.error('Transaction confirmation failed:', error);\n      throw error;\n    }\n  }\n\n  // Submit signed transaction\n  async submitTransaction(signedTxn) {\n    try {\n      const txId = await this.algodClient.sendRawTransaction(signedTxn).do();\n      return txId;\n    } catch (error) {\n      console.error('Failed to submit transaction:', error);\n      throw error;\n    }\n  }\n\n  // Submit multiple transactions as a group\n  async submitTransactionGroup(signedTxns) {\n    try {\n      // The signed transactions are already in the correct format from Lute wallet\n      // We can submit them directly\n      const txId = await this.algodClient.sendRawTransaction(signedTxns).do();\n      return txId;\n    } catch (error) {\n      console.error('Failed to submit transaction group:', error);\n      throw error;\n    }\n  }\n}\n\n// Create and export singleton instance\nconst contractUtils = new ContractUtils();\nexport default contractUtils;","map":{"version":3,"names":["algosdk","CONTRACT_CONFIG","appId","parseInt","process","env","REACT_APP_CONTRACT_APP_ID","algodClient","Algodv2","REACT_APP_ALGOD_URL","indexerClient","Indexer","REACT_APP_INDEXER_URL","CONTRACT_METHODS","CREATE_BOUNTY","ACCEPT_BOUNTY","APPROVE_BOUNTY","CLAIM_BOUNTY","REFUND_BOUNTY","AUTO_REFUND","GET_BOUNTY","BOUNTY_STATUS","OPEN","ACCEPTED","APPROVED","CLAIMED","REFUNDED","GLOBAL_STATE_KEYS","BOUNTY_COUNT","CLIENT_ADDR","FREELANCER_ADDR","AMOUNT","DEADLINE","STATUS","TASK_DESCRIPTION","VERIFIER_ADDR","ContractUtils","constructor","setAppId","getAppId","getSuggestedParams","params","getTransactionParams","do","error","console","createAppCallTransaction","sender","method","args","accounts","note","Error","log","length","suggestedParams","appArgs","Uint8Array","TextEncoder","encode","forEach","arg","push","encodeUint64","txn","makeApplicationCallTxnFromObject","from","appIndex","onComplete","OnApplicationComplete","NoOpOC","undefined","createPaymentTransaction","receiver","amount","makePaymentTxnWithSuggestedParamsFromObject","to","Math","round","createBounty","deadline","taskDescription","verifierAddress","trim","deadlineTimestamp","floor","Date","getTime","now","amountMicroAlgo","paymentTxn","getContractAddress","appCallTxn","assignGroupID","acceptBounty","approveBounty","claimBounty","refundBounty","autoRefundBounty","appAddress","getApplicationAddress","getContractState","appInfo","getApplicationByID","globalState","parsedState","item","key","atob","value","type","uint","bytes","getCurrentBounty","state","bountyCount","clientAddress","freelancerAddress","status","canPerformAction","userAddress","action","bountyInfo","getStatusName","statusCode","waitForConfirmation","txId","timeout","confirmedTxn","submitTransaction","signedTxn","sendRawTransaction","submitTransactionGroup","signedTxns","contractUtils"],"sources":["C:/Users/Aditya singh/AlgoEase/frontend/src/utils/contractUtils.js"],"sourcesContent":["// Smart Contract Utilities for AlgoEase\r\nimport algosdk from 'algosdk/dist/browser/algosdk.min.js';\r\n\r\n// Contract configuration\r\nconst CONTRACT_CONFIG = {\r\n  // These will be set after contract deployment\r\n  appId: parseInt(process.env.REACT_APP_CONTRACT_APP_ID) || 748433709,\r\n  // TestNet configuration\r\n  algodClient: new algosdk.Algodv2(\r\n    '',\r\n    process.env.REACT_APP_ALGOD_URL || 'https://testnet-api.algonode.cloud',\r\n    ''\r\n  ),\r\n  indexerClient: new algosdk.Indexer(\r\n    '',\r\n    process.env.REACT_APP_INDEXER_URL || 'https://testnet-idx.algonode.cloud',\r\n    ''\r\n  )\r\n};\r\n\r\n// Contract method constants\r\nexport const CONTRACT_METHODS = {\r\n  CREATE_BOUNTY: 'create_bounty',\r\n  ACCEPT_BOUNTY: 'accept_bounty',\r\n  APPROVE_BOUNTY: 'approve_bounty',\r\n  CLAIM_BOUNTY: 'claim',\r\n  REFUND_BOUNTY: 'refund',\r\n  AUTO_REFUND: 'auto_refund',\r\n  GET_BOUNTY: 'get_bounty'\r\n};\r\n\r\n// Status constants matching the smart contract\r\nexport const BOUNTY_STATUS = {\r\n  OPEN: 0,\r\n  ACCEPTED: 1,\r\n  APPROVED: 2,\r\n  CLAIMED: 3,\r\n  REFUNDED: 4\r\n};\r\n\r\n// Global state keys from the contract\r\nexport const GLOBAL_STATE_KEYS = {\r\n  BOUNTY_COUNT: 'bounty_count',\r\n  CLIENT_ADDR: 'client_addr',\r\n  FREELANCER_ADDR: 'freelancer_addr',\r\n  AMOUNT: 'amount',\r\n  DEADLINE: 'deadline',\r\n  STATUS: 'status',\r\n  TASK_DESCRIPTION: 'task_desc',\r\n  VERIFIER_ADDR: 'verifier_addr'\r\n};\r\n\r\nclass ContractUtils {\r\n  constructor() {\r\n    this.algodClient = CONTRACT_CONFIG.algodClient;\r\n    this.indexerClient = CONTRACT_CONFIG.indexerClient;\r\n    this.appId = CONTRACT_CONFIG.appId;\r\n  }\r\n\r\n  // Set contract app ID after deployment\r\n  setAppId(appId) {\r\n    this.appId = parseInt(appId);\r\n  }\r\n\r\n  // Get current contract app ID\r\n  getAppId() {\r\n    return this.appId;\r\n  }\r\n\r\n  // Get suggested transaction parameters\r\n  async getSuggestedParams() {\r\n    try {\r\n      const params = await this.algodClient.getTransactionParams().do();\r\n      return params;\r\n    } catch (error) {\r\n      console.error('Failed to get transaction parameters:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Create application call transaction\r\n  async createAppCallTransaction(sender, method, args = [], accounts = [], note = '') {\r\n    if (!this.appId) {\r\n      throw new Error('Contract app ID not set. Please deploy the contract first.');\r\n    }\r\n    \r\n    console.log('Creating app call transaction:');\r\n    console.log('  - App ID:', this.appId);\r\n    console.log('  - Method:', method);\r\n    console.log('  - Sender:', sender);\r\n    console.log('  - Accounts array:', accounts);\r\n    console.log('  - Accounts length:', accounts.length);\r\n\r\n    const suggestedParams = await this.getSuggestedParams();\r\n    \r\n    const appArgs = [new Uint8Array(new TextEncoder().encode(method))];\r\n    args.forEach(arg => {\r\n      if (typeof arg === 'string') {\r\n        appArgs.push(new Uint8Array(new TextEncoder().encode(arg)));\r\n      } else if (typeof arg === 'number') {\r\n        appArgs.push(algosdk.encodeUint64(arg));\r\n      } else {\r\n        appArgs.push(arg);\r\n      }\r\n    });\r\n\r\n    const txn = algosdk.makeApplicationCallTxnFromObject({\r\n      from: sender,\r\n      appIndex: this.appId,\r\n      onComplete: algosdk.OnApplicationComplete.NoOpOC,\r\n      suggestedParams,\r\n      appArgs,\r\n      accounts,\r\n      note: note ? new Uint8Array(new TextEncoder().encode(note)) : undefined\r\n    });\r\n\r\n    return txn;\r\n  }\r\n\r\n  // Create payment transaction\r\n  async createPaymentTransaction(sender, receiver, amount, note = '') {\r\n    const suggestedParams = await this.getSuggestedParams();\r\n    \r\n    const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\r\n      from: sender,\r\n      to: receiver,\r\n      amount: Math.round(amount * 1000000), // Convert ALGO to microALGO\r\n      suggestedParams,\r\n      note: note ? new Uint8Array(new TextEncoder().encode(note)) : undefined\r\n    });\r\n\r\n    return txn;\r\n  }\r\n\r\n  // Create bounty on smart contract\r\n  async createBounty(sender, amount, deadline, taskDescription, verifierAddress) {\r\n    try {\r\n      // Validate and ensure verifierAddress is set\r\n      if (!verifierAddress || verifierAddress.trim() === '') {\r\n        verifierAddress = sender; // Use sender as verifier if not specified\r\n      }\r\n      \r\n      console.log('Creating bounty with verifier:', verifierAddress);\r\n      \r\n      // Convert deadline to timestamp\r\n      const deadlineTimestamp = Math.floor(new Date(deadline).getTime() / 1000);\r\n      \r\n      // Validate deadline is in the future\r\n      const now = Math.floor(Date.now() / 1000);\r\n      if (deadlineTimestamp <= now) {\r\n        throw new Error('Deadline must be in the future');\r\n      }\r\n      \r\n      // Convert amount to microALGO\r\n      const amountMicroAlgo = Math.round(amount * 1000000);\r\n\r\n      // Create payment transaction to send funds to contract (must be first)\r\n      const paymentTxn = await this.createPaymentTransaction(\r\n        sender,\r\n        await this.getContractAddress(),\r\n        amount, // Amount in ALGO (function will convert to microALGO)\r\n        'AlgoEase: Bounty Payment'\r\n      );\r\n\r\n      // Create the application call transaction (must be second)\r\n      // IMPORTANT: accounts array must not be empty - pass verifierAddress\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.CREATE_BOUNTY,\r\n        [amountMicroAlgo, deadlineTimestamp, taskDescription],\r\n        [verifierAddress],  // This makes Txn.accounts.length() = 2 (sender + verifier)\r\n        'AlgoEase: Create Bounty'\r\n      );\r\n\r\n      // Assign group ID to transactions\r\n      algosdk.assignGroupID([paymentTxn, appCallTxn]);\r\n\r\n      return [paymentTxn, appCallTxn];\r\n    } catch (error) {\r\n      console.error('Failed to create bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Accept bounty\r\n  async acceptBounty(sender) {\r\n    try {\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.ACCEPT_BOUNTY,\r\n        [],\r\n        [],\r\n        'AlgoEase: Accept Bounty'\r\n      );\r\n\r\n      return appCallTxn;\r\n    } catch (error) {\r\n      console.error('Failed to create accept bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Approve bounty (verifier only)\r\n  async approveBounty(sender) {\r\n    try {\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.APPROVE_BOUNTY,\r\n        [],\r\n        [],\r\n        'AlgoEase: Approve Bounty'\r\n      );\r\n\r\n      return appCallTxn;\r\n    } catch (error) {\r\n      console.error('Failed to create approve bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Claim bounty payment\r\n  async claimBounty(sender) {\r\n    try {\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.CLAIM_BOUNTY,\r\n        [],\r\n        [],\r\n        'AlgoEase: Claim Bounty'\r\n      );\r\n\r\n      return appCallTxn;\r\n    } catch (error) {\r\n      console.error('Failed to create claim bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Refund bounty (manual refund by client or verifier)\r\n  async refundBounty(sender) {\r\n    try {\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.REFUND_BOUNTY,\r\n        [],\r\n        [],\r\n        'AlgoEase: Refund Bounty'\r\n      );\r\n\r\n      return appCallTxn;\r\n    } catch (error) {\r\n      console.error('Failed to create refund bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Auto refund bounty (when deadline has passed)\r\n  async autoRefundBounty(sender) {\r\n    try {\r\n      const appCallTxn = await this.createAppCallTransaction(\r\n        sender,\r\n        CONTRACT_METHODS.AUTO_REFUND,\r\n        [],\r\n        [],\r\n        'AlgoEase: Auto Refund Bounty'\r\n      );\r\n\r\n      return appCallTxn;\r\n    } catch (error) {\r\n      console.error('Failed to create auto refund bounty transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get contract address\r\n  async getContractAddress() {\r\n    if (!this.appId) {\r\n      throw new Error('Contract app ID not set');\r\n    }\r\n\r\n    try {\r\n      // Calculate the application address from the app ID\r\n      // This is the address where the smart contract funds are stored\r\n      const appAddress = algosdk.getApplicationAddress(this.appId);\r\n      return appAddress;\r\n    } catch (error) {\r\n      console.error('Failed to get contract address:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get contract state\r\n  async getContractState() {\r\n    if (!this.appId) {\r\n      throw new Error('Contract app ID not set');\r\n    }\r\n\r\n    try {\r\n      const appInfo = await this.algodClient.getApplicationByID(this.appId).do();\r\n      const globalState = appInfo.params['global-state'] || [];\r\n      \r\n      // Parse global state\r\n      const parsedState = {};\r\n      globalState.forEach(item => {\r\n        const key = atob(item.key); // Decode base64 to string\r\n        const value = item.value;\r\n        \r\n        if (value.type === 1) { // uint64\r\n          parsedState[key] = value.uint;\r\n        } else if (value.type === 2) { // bytes\r\n          parsedState[key] = atob(value.bytes); // Decode base64 to string\r\n        }\r\n      });\r\n\r\n      return parsedState;\r\n    } catch (error) {\r\n      console.error('Failed to get contract state:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get current bounty information\r\n  async getCurrentBounty() {\r\n    try {\r\n      const state = await this.getContractState();\r\n      \r\n      if (!state[GLOBAL_STATE_KEYS.BOUNTY_COUNT] || state[GLOBAL_STATE_KEYS.BOUNTY_COUNT] === 0) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        bountyCount: state[GLOBAL_STATE_KEYS.BOUNTY_COUNT],\r\n        clientAddress: state[GLOBAL_STATE_KEYS.CLIENT_ADDR],\r\n        freelancerAddress: state[GLOBAL_STATE_KEYS.FREELANCER_ADDR],\r\n        amount: state[GLOBAL_STATE_KEYS.AMOUNT] / 1000000, // Convert from microALGO to ALGO\r\n        deadline: new Date(state[GLOBAL_STATE_KEYS.DEADLINE] * 1000),\r\n        status: state[GLOBAL_STATE_KEYS.STATUS],\r\n        taskDescription: state[GLOBAL_STATE_KEYS.TASK_DESCRIPTION],\r\n        verifierAddress: state[GLOBAL_STATE_KEYS.VERIFIER_ADDR]\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to get current bounty:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check if user can perform action\r\n  canPerformAction(userAddress, action, bountyInfo) {\r\n    if (!bountyInfo) return false;\r\n\r\n    switch (action) {\r\n      case 'accept':\r\n        return bountyInfo.status === BOUNTY_STATUS.OPEN && \r\n               userAddress !== bountyInfo.clientAddress;\r\n      \r\n      case 'approve':\r\n        return bountyInfo.status === BOUNTY_STATUS.ACCEPTED && \r\n               userAddress === bountyInfo.verifierAddress;\r\n      \r\n      case 'claim':\r\n        return bountyInfo.status === BOUNTY_STATUS.APPROVED && \r\n               userAddress === bountyInfo.freelancerAddress;\r\n      \r\n      case 'refund':\r\n        return (bountyInfo.status === BOUNTY_STATUS.OPEN || \r\n                bountyInfo.status === BOUNTY_STATUS.ACCEPTED) &&\r\n               (userAddress === bountyInfo.clientAddress || \r\n                userAddress === bountyInfo.verifierAddress);\r\n      \r\n      case 'auto_refund':\r\n        return (bountyInfo.status === BOUNTY_STATUS.OPEN || \r\n                bountyInfo.status === BOUNTY_STATUS.ACCEPTED) &&\r\n               Date.now() / 1000 > bountyInfo.deadline.getTime() / 1000;\r\n      \r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  // Get status name from status code\r\n  getStatusName(statusCode) {\r\n    switch (statusCode) {\r\n      case BOUNTY_STATUS.OPEN: return 'open';\r\n      case BOUNTY_STATUS.ACCEPTED: return 'accepted';\r\n      case BOUNTY_STATUS.APPROVED: return 'approved';\r\n      case BOUNTY_STATUS.CLAIMED: return 'claimed';\r\n      case BOUNTY_STATUS.REFUNDED: return 'refunded';\r\n      default: return 'unknown';\r\n    }\r\n  }\r\n\r\n  // Wait for transaction confirmation\r\n  async waitForConfirmation(txId, timeout = 10000) {\r\n    try {\r\n      const confirmedTxn = await algosdk.waitForConfirmation(\r\n        this.algodClient,\r\n        txId,\r\n        timeout\r\n      );\r\n      return confirmedTxn;\r\n    } catch (error) {\r\n      console.error('Transaction confirmation failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Submit signed transaction\r\n  async submitTransaction(signedTxn) {\r\n    try {\r\n      const txId = await this.algodClient.sendRawTransaction(signedTxn).do();\r\n      return txId;\r\n    } catch (error) {\r\n      console.error('Failed to submit transaction:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Submit multiple transactions as a group\r\n  async submitTransactionGroup(signedTxns) {\r\n    try {\r\n      // The signed transactions are already in the correct format from Lute wallet\r\n      // We can submit them directly\r\n      const txId = await this.algodClient.sendRawTransaction(signedTxns).do();\r\n      return txId;\r\n    } catch (error) {\r\n      console.error('Failed to submit transaction group:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nconst contractUtils = new ContractUtils();\r\nexport default contractUtils;\r\n"],"mappings":"AAAA;AACA,OAAOA,OAAO,MAAM,qCAAqC;;AAEzD;AACA,MAAMC,eAAe,GAAG;EACtB;EACAC,KAAK,EAAEC,QAAQ,CAACC,OAAO,CAACC,GAAG,CAACC,yBAAyB,CAAC,IAAI,SAAS;EACnE;EACAC,WAAW,EAAE,IAAIP,OAAO,CAACQ,OAAO,CAC9B,EAAE,EACFJ,OAAO,CAACC,GAAG,CAACI,mBAAmB,IAAI,oCAAoC,EACvE,EACF,CAAC;EACDC,aAAa,EAAE,IAAIV,OAAO,CAACW,OAAO,CAChC,EAAE,EACFP,OAAO,CAACC,GAAG,CAACO,qBAAqB,IAAI,oCAAoC,EACzE,EACF;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,gBAAgB,GAAG;EAC9BC,aAAa,EAAE,eAAe;EAC9BC,aAAa,EAAE,eAAe;EAC9BC,cAAc,EAAE,gBAAgB;EAChCC,YAAY,EAAE,OAAO;EACrBC,aAAa,EAAE,QAAQ;EACvBC,WAAW,EAAE,aAAa;EAC1BC,UAAU,EAAE;AACd,CAAC;;AAED;AACA,OAAO,MAAMC,aAAa,GAAG;EAC3BC,IAAI,EAAE,CAAC;EACPC,QAAQ,EAAE,CAAC;EACXC,QAAQ,EAAE,CAAC;EACXC,OAAO,EAAE,CAAC;EACVC,QAAQ,EAAE;AACZ,CAAC;;AAED;AACA,OAAO,MAAMC,iBAAiB,GAAG;EAC/BC,YAAY,EAAE,cAAc;EAC5BC,WAAW,EAAE,aAAa;EAC1BC,eAAe,EAAE,iBAAiB;EAClCC,MAAM,EAAE,QAAQ;EAChBC,QAAQ,EAAE,UAAU;EACpBC,MAAM,EAAE,QAAQ;EAChBC,gBAAgB,EAAE,WAAW;EAC7BC,aAAa,EAAE;AACjB,CAAC;AAED,MAAMC,aAAa,CAAC;EAClBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAC9B,WAAW,GAAGN,eAAe,CAACM,WAAW;IAC9C,IAAI,CAACG,aAAa,GAAGT,eAAe,CAACS,aAAa;IAClD,IAAI,CAACR,KAAK,GAAGD,eAAe,CAACC,KAAK;EACpC;;EAEA;EACAoC,QAAQA,CAACpC,KAAK,EAAE;IACd,IAAI,CAACA,KAAK,GAAGC,QAAQ,CAACD,KAAK,CAAC;EAC9B;;EAEA;EACAqC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACrC,KAAK;EACnB;;EAEA;EACA,MAAMsC,kBAAkBA,CAAA,EAAG;IACzB,IAAI;MACF,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAClC,WAAW,CAACmC,oBAAoB,CAAC,CAAC,CAACC,EAAE,CAAC,CAAC;MACjE,OAAOF,MAAM;IACf,CAAC,CAAC,OAAOG,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;MAC7D,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAME,wBAAwBA,CAACC,MAAM,EAAEC,MAAM,EAAEC,IAAI,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,EAAEC,IAAI,GAAG,EAAE,EAAE;IAClF,IAAI,CAAC,IAAI,CAACjD,KAAK,EAAE;MACf,MAAM,IAAIkD,KAAK,CAAC,4DAA4D,CAAC;IAC/E;IAEAP,OAAO,CAACQ,GAAG,CAAC,gCAAgC,CAAC;IAC7CR,OAAO,CAACQ,GAAG,CAAC,aAAa,EAAE,IAAI,CAACnD,KAAK,CAAC;IACtC2C,OAAO,CAACQ,GAAG,CAAC,aAAa,EAAEL,MAAM,CAAC;IAClCH,OAAO,CAACQ,GAAG,CAAC,aAAa,EAAEN,MAAM,CAAC;IAClCF,OAAO,CAACQ,GAAG,CAAC,qBAAqB,EAAEH,QAAQ,CAAC;IAC5CL,OAAO,CAACQ,GAAG,CAAC,sBAAsB,EAAEH,QAAQ,CAACI,MAAM,CAAC;IAEpD,MAAMC,eAAe,GAAG,MAAM,IAAI,CAACf,kBAAkB,CAAC,CAAC;IAEvD,MAAMgB,OAAO,GAAG,CAAC,IAAIC,UAAU,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACX,MAAM,CAAC,CAAC,CAAC;IAClEC,IAAI,CAACW,OAAO,CAACC,GAAG,IAAI;MAClB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAC3BL,OAAO,CAACM,IAAI,CAAC,IAAIL,UAAU,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACE,GAAG,CAAC,CAAC,CAAC;MAC7D,CAAC,MAAM,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAClCL,OAAO,CAACM,IAAI,CAAC9D,OAAO,CAAC+D,YAAY,CAACF,GAAG,CAAC,CAAC;MACzC,CAAC,MAAM;QACLL,OAAO,CAACM,IAAI,CAACD,GAAG,CAAC;MACnB;IACF,CAAC,CAAC;IAEF,MAAMG,GAAG,GAAGhE,OAAO,CAACiE,gCAAgC,CAAC;MACnDC,IAAI,EAAEnB,MAAM;MACZoB,QAAQ,EAAE,IAAI,CAACjE,KAAK;MACpBkE,UAAU,EAAEpE,OAAO,CAACqE,qBAAqB,CAACC,MAAM;MAChDf,eAAe;MACfC,OAAO;MACPN,QAAQ;MACRC,IAAI,EAAEA,IAAI,GAAG,IAAIM,UAAU,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACR,IAAI,CAAC,CAAC,GAAGoB;IAChE,CAAC,CAAC;IAEF,OAAOP,GAAG;EACZ;;EAEA;EACA,MAAMQ,wBAAwBA,CAACzB,MAAM,EAAE0B,QAAQ,EAAEC,MAAM,EAAEvB,IAAI,GAAG,EAAE,EAAE;IAClE,MAAMI,eAAe,GAAG,MAAM,IAAI,CAACf,kBAAkB,CAAC,CAAC;IAEvD,MAAMwB,GAAG,GAAGhE,OAAO,CAAC2E,2CAA2C,CAAC;MAC9DT,IAAI,EAAEnB,MAAM;MACZ6B,EAAE,EAAEH,QAAQ;MACZC,MAAM,EAAEG,IAAI,CAACC,KAAK,CAACJ,MAAM,GAAG,OAAO,CAAC;MAAE;MACtCnB,eAAe;MACfJ,IAAI,EAAEA,IAAI,GAAG,IAAIM,UAAU,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACR,IAAI,CAAC,CAAC,GAAGoB;IAChE,CAAC,CAAC;IAEF,OAAOP,GAAG;EACZ;;EAEA;EACA,MAAMe,YAAYA,CAAChC,MAAM,EAAE2B,MAAM,EAAEM,QAAQ,EAAEC,eAAe,EAAEC,eAAe,EAAE;IAC7E,IAAI;MACF;MACA,IAAI,CAACA,eAAe,IAAIA,eAAe,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QACrDD,eAAe,GAAGnC,MAAM,CAAC,CAAC;MAC5B;MAEAF,OAAO,CAACQ,GAAG,CAAC,gCAAgC,EAAE6B,eAAe,CAAC;;MAE9D;MACA,MAAME,iBAAiB,GAAGP,IAAI,CAACQ,KAAK,CAAC,IAAIC,IAAI,CAACN,QAAQ,CAAC,CAACO,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC;;MAEzE;MACA,MAAMC,GAAG,GAAGX,IAAI,CAACQ,KAAK,CAACC,IAAI,CAACE,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;MACzC,IAAIJ,iBAAiB,IAAII,GAAG,EAAE;QAC5B,MAAM,IAAIpC,KAAK,CAAC,gCAAgC,CAAC;MACnD;;MAEA;MACA,MAAMqC,eAAe,GAAGZ,IAAI,CAACC,KAAK,CAACJ,MAAM,GAAG,OAAO,CAAC;;MAEpD;MACA,MAAMgB,UAAU,GAAG,MAAM,IAAI,CAAClB,wBAAwB,CACpDzB,MAAM,EACN,MAAM,IAAI,CAAC4C,kBAAkB,CAAC,CAAC,EAC/BjB,MAAM;MAAE;MACR,0BACF,CAAC;;MAED;MACA;MACA,MAAMkB,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACC,aAAa,EAC9B,CAAC2E,eAAe,EAAEL,iBAAiB,EAAEH,eAAe,CAAC,EACrD,CAACC,eAAe,CAAC;MAAG;MACpB,yBACF,CAAC;;MAED;MACAlF,OAAO,CAAC6F,aAAa,CAAC,CAACH,UAAU,EAAEE,UAAU,CAAC,CAAC;MAE/C,OAAO,CAACF,UAAU,EAAEE,UAAU,CAAC;IACjC,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;MAC5D,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMkD,YAAYA,CAAC/C,MAAM,EAAE;IACzB,IAAI;MACF,MAAM6C,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACE,aAAa,EAC9B,EAAE,EACF,EAAE,EACF,yBACF,CAAC;MAED,OAAO6E,UAAU;IACnB,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;MACnE,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMmD,aAAaA,CAAChD,MAAM,EAAE;IAC1B,IAAI;MACF,MAAM6C,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACG,cAAc,EAC/B,EAAE,EACF,EAAE,EACF,0BACF,CAAC;MAED,OAAO4E,UAAU;IACnB,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8CAA8C,EAAEA,KAAK,CAAC;MACpE,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMoD,WAAWA,CAACjD,MAAM,EAAE;IACxB,IAAI;MACF,MAAM6C,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACI,YAAY,EAC7B,EAAE,EACF,EAAE,EACF,wBACF,CAAC;MAED,OAAO2E,UAAU;IACnB,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MAClE,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMqD,YAAYA,CAAClD,MAAM,EAAE;IACzB,IAAI;MACF,MAAM6C,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACK,aAAa,EAC9B,EAAE,EACF,EAAE,EACF,yBACF,CAAC;MAED,OAAO0E,UAAU;IACnB,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;MACnE,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMsD,gBAAgBA,CAACnD,MAAM,EAAE;IAC7B,IAAI;MACF,MAAM6C,UAAU,GAAG,MAAM,IAAI,CAAC9C,wBAAwB,CACpDC,MAAM,EACNlC,gBAAgB,CAACM,WAAW,EAC5B,EAAE,EACF,EAAE,EACF,8BACF,CAAC;MAED,OAAOyE,UAAU;IACnB,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,kDAAkD,EAAEA,KAAK,CAAC;MACxE,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAM+C,kBAAkBA,CAAA,EAAG;IACzB,IAAI,CAAC,IAAI,CAACzF,KAAK,EAAE;MACf,MAAM,IAAIkD,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IAEA,IAAI;MACF;MACA;MACA,MAAM+C,UAAU,GAAGnG,OAAO,CAACoG,qBAAqB,CAAC,IAAI,CAAClG,KAAK,CAAC;MAC5D,OAAOiG,UAAU;IACnB,CAAC,CAAC,OAAOvD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMyD,gBAAgBA,CAAA,EAAG;IACvB,IAAI,CAAC,IAAI,CAACnG,KAAK,EAAE;MACf,MAAM,IAAIkD,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IAEA,IAAI;MACF,MAAMkD,OAAO,GAAG,MAAM,IAAI,CAAC/F,WAAW,CAACgG,kBAAkB,CAAC,IAAI,CAACrG,KAAK,CAAC,CAACyC,EAAE,CAAC,CAAC;MAC1E,MAAM6D,WAAW,GAAGF,OAAO,CAAC7D,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE;;MAExD;MACA,MAAMgE,WAAW,GAAG,CAAC,CAAC;MACtBD,WAAW,CAAC5C,OAAO,CAAC8C,IAAI,IAAI;QAC1B,MAAMC,GAAG,GAAGC,IAAI,CAACF,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC;QAC5B,MAAME,KAAK,GAAGH,IAAI,CAACG,KAAK;QAExB,IAAIA,KAAK,CAACC,IAAI,KAAK,CAAC,EAAE;UAAE;UACtBL,WAAW,CAACE,GAAG,CAAC,GAAGE,KAAK,CAACE,IAAI;QAC/B,CAAC,MAAM,IAAIF,KAAK,CAACC,IAAI,KAAK,CAAC,EAAE;UAAE;UAC7BL,WAAW,CAACE,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC;QACxC;MACF,CAAC,CAAC;MAEF,OAAOP,WAAW;IACpB,CAAC,CAAC,OAAO7D,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMqE,gBAAgBA,CAAA,EAAG;IACvB,IAAI;MACF,MAAMC,KAAK,GAAG,MAAM,IAAI,CAACb,gBAAgB,CAAC,CAAC;MAE3C,IAAI,CAACa,KAAK,CAACvF,iBAAiB,CAACC,YAAY,CAAC,IAAIsF,KAAK,CAACvF,iBAAiB,CAACC,YAAY,CAAC,KAAK,CAAC,EAAE;QACzF,OAAO,IAAI;MACb;MAEA,OAAO;QACLuF,WAAW,EAAED,KAAK,CAACvF,iBAAiB,CAACC,YAAY,CAAC;QAClDwF,aAAa,EAAEF,KAAK,CAACvF,iBAAiB,CAACE,WAAW,CAAC;QACnDwF,iBAAiB,EAAEH,KAAK,CAACvF,iBAAiB,CAACG,eAAe,CAAC;QAC3D4C,MAAM,EAAEwC,KAAK,CAACvF,iBAAiB,CAACI,MAAM,CAAC,GAAG,OAAO;QAAE;QACnDiD,QAAQ,EAAE,IAAIM,IAAI,CAAC4B,KAAK,CAACvF,iBAAiB,CAACK,QAAQ,CAAC,GAAG,IAAI,CAAC;QAC5DsF,MAAM,EAAEJ,KAAK,CAACvF,iBAAiB,CAACM,MAAM,CAAC;QACvCgD,eAAe,EAAEiC,KAAK,CAACvF,iBAAiB,CAACO,gBAAgB,CAAC;QAC1DgD,eAAe,EAAEgC,KAAK,CAACvF,iBAAiB,CAACQ,aAAa;MACxD,CAAC;IACH,CAAC,CAAC,OAAOS,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD,MAAMA,KAAK;IACb;EACF;;EAEA;EACA2E,gBAAgBA,CAACC,WAAW,EAAEC,MAAM,EAAEC,UAAU,EAAE;IAChD,IAAI,CAACA,UAAU,EAAE,OAAO,KAAK;IAE7B,QAAQD,MAAM;MACZ,KAAK,QAAQ;QACX,OAAOC,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACC,IAAI,IACxCkG,WAAW,KAAKE,UAAU,CAACN,aAAa;MAEjD,KAAK,SAAS;QACZ,OAAOM,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACE,QAAQ,IAC5CiG,WAAW,KAAKE,UAAU,CAACxC,eAAe;MAEnD,KAAK,OAAO;QACV,OAAOwC,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACG,QAAQ,IAC5CgG,WAAW,KAAKE,UAAU,CAACL,iBAAiB;MAErD,KAAK,QAAQ;QACX,OAAO,CAACK,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACC,IAAI,IACxCoG,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACE,QAAQ,MAC5CiG,WAAW,KAAKE,UAAU,CAACN,aAAa,IACxCI,WAAW,KAAKE,UAAU,CAACxC,eAAe,CAAC;MAErD,KAAK,aAAa;QAChB,OAAO,CAACwC,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACC,IAAI,IACxCoG,UAAU,CAACJ,MAAM,KAAKjG,aAAa,CAACE,QAAQ,KAC7C+D,IAAI,CAACE,GAAG,CAAC,CAAC,GAAG,IAAI,GAAGkC,UAAU,CAAC1C,QAAQ,CAACO,OAAO,CAAC,CAAC,GAAG,IAAI;MAEjE;QACE,OAAO,KAAK;IAChB;EACF;;EAEA;EACAoC,aAAaA,CAACC,UAAU,EAAE;IACxB,QAAQA,UAAU;MAChB,KAAKvG,aAAa,CAACC,IAAI;QAAE,OAAO,MAAM;MACtC,KAAKD,aAAa,CAACE,QAAQ;QAAE,OAAO,UAAU;MAC9C,KAAKF,aAAa,CAACG,QAAQ;QAAE,OAAO,UAAU;MAC9C,KAAKH,aAAa,CAACI,OAAO;QAAE,OAAO,SAAS;MAC5C,KAAKJ,aAAa,CAACK,QAAQ;QAAE,OAAO,UAAU;MAC9C;QAAS,OAAO,SAAS;IAC3B;EACF;;EAEA;EACA,MAAMmG,mBAAmBA,CAACC,IAAI,EAAEC,OAAO,GAAG,KAAK,EAAE;IAC/C,IAAI;MACF,MAAMC,YAAY,GAAG,MAAMhI,OAAO,CAAC6H,mBAAmB,CACpD,IAAI,CAACtH,WAAW,EAChBuH,IAAI,EACJC,OACF,CAAC;MACD,OAAOC,YAAY;IACrB,CAAC,CAAC,OAAOpF,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMqF,iBAAiBA,CAACC,SAAS,EAAE;IACjC,IAAI;MACF,MAAMJ,IAAI,GAAG,MAAM,IAAI,CAACvH,WAAW,CAAC4H,kBAAkB,CAACD,SAAS,CAAC,CAACvF,EAAE,CAAC,CAAC;MACtE,OAAOmF,IAAI;IACb,CAAC,CAAC,OAAOlF,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD,MAAMA,KAAK;IACb;EACF;;EAEA;EACA,MAAMwF,sBAAsBA,CAACC,UAAU,EAAE;IACvC,IAAI;MACF;MACA;MACA,MAAMP,IAAI,GAAG,MAAM,IAAI,CAACvH,WAAW,CAAC4H,kBAAkB,CAACE,UAAU,CAAC,CAAC1F,EAAE,CAAC,CAAC;MACvE,OAAOmF,IAAI;IACb,CAAC,CAAC,OAAOlF,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,MAAMA,KAAK;IACb;EACF;AACF;;AAEA;AACA,MAAM0F,aAAa,GAAG,IAAIlG,aAAa,CAAC,CAAC;AACzC,eAAekG,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}