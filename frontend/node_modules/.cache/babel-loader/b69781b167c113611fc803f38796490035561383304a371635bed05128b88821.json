{"ast":null,"code":"import { Buffer } from 'buffer';\nimport base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as utils from '../utils/utils';\nimport { encodeUint64 } from './uint64';\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nexport const ALGORAND_ZERO_ADDRESS_STRING = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nconst APP_ID_PREFIX = Buffer.from('appID');\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nexport const INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nexport const INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nexport const INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nexport const UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n/**\r\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\r\n * @param address - an Algorand address with checksum.\r\n * @returns the decoded form of the address's public key and checksum\r\n */\nexport function decodeAddress(address) {\n  if (typeof address !== 'string' || address.length !== ALGORAND_ADDRESS_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // try to decode\n  const decoded = base32.decode.asBytes(address.toString());\n  // Sanity check\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // Find publickey and checksum\n  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  const cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n  // Compute checksum\n  const checksum = nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH);\n  // Check if the checksum and the address are equal\n  if (!utils.arrayEqual(checksum, cs)) throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n  return {\n    publicKey: pk,\n    checksum: cs\n  };\n}\n/**\r\n * isValidAddress checks if a string is a valid Algorand address.\r\n * @param address - an Algorand address with checksum.\r\n * @returns true if valid, false otherwise\r\n */\nexport function isValidAddress(address) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\r\n * @param address - a raw Algorand address\r\n * @returns the address and checksum encoded as a string.\r\n */\nexport function encodeAddress(address) {\n  // compute checksum\n  const checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  const addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\r\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\r\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\r\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\r\n * Encoding this output yields a human readable address.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - array of typed array public keys\r\n */\nexport function fromMultisigPreImg({\n  version,\n  threshold,\n  pks\n}) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Uint8Array(nacl.genericHash(merged));\n}\n/**\r\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\r\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - array of encoded addresses\r\n */\nexport function fromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs\n}) {\n  const pks = addrs.map(addr => decodeAddress(addr).publicKey);\n  return encodeAddress(fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  }));\n}\n/**\r\n * Get the escrow address of an application.\r\n * @param appID - The ID of the application.\r\n * @returns The address corresponding to that application's escrow account.\r\n */\nexport function getApplicationAddress(appID) {\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  const hash = nacl.genericHash(toBeSigned);\n  return encodeAddress(new Uint8Array(hash));\n}","map":{"version":3,"names":["Buffer","base32","nacl","utils","encodeUint64","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","APP_ID_PREFIX","from","MALFORMED_ADDRESS_ERROR_MSG","CHECKSUM_ADDRESS_ERROR_MSG","INVALID_MSIG_VERSION_ERROR_MSG","INVALID_MSIG_THRESHOLD_ERROR_MSG","INVALID_MSIG_PK_ERROR_MSG","UNEXPECTED_PK_LEN_ERROR_MSG","decodeAddress","address","length","Error","decoded","decode","asBytes","toString","pk","slice","cs","PUBLIC_KEY_LENGTH","checksum","genericHash","HASH_BYTES_LENGTH","arrayEqual","publicKey","isValidAddress","e","encodeAddress","addr","encode","concatArrays","fromMultisigPreImg","version","threshold","pks","pkLen","merged","set","i","fromMultisigPreImgAddrs","addrs","map","getApplicationAddress","appID","toBeSigned","hash"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\encoding\\address.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport base32 from 'hi-base32';\r\nimport * as nacl from '../nacl/naclWrappers';\r\nimport * as utils from '../utils/utils';\r\nimport { encodeUint64 } from './uint64';\r\nimport { Address } from '../types/address';\r\nimport { MultisigMetadata } from '../types/multisig';\r\n\r\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\r\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\r\nconst ALGORAND_ADDRESS_LENGTH = 58;\r\nexport const ALGORAND_ZERO_ADDRESS_STRING =\r\n  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\r\n\r\n// Convert \"MultisigAddr\" UTF-8 to byte array\r\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([\r\n  77,\r\n  117,\r\n  108,\r\n  116,\r\n  105,\r\n  115,\r\n  105,\r\n  103,\r\n  65,\r\n  100,\r\n  100,\r\n  114,\r\n]);\r\n\r\nconst APP_ID_PREFIX = Buffer.from('appID');\r\n\r\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\r\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\r\nexport const INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\r\nexport const INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\r\nexport const INVALID_MSIG_PK_ERROR_MSG =\r\n  'bad multisig public key - wrong length';\r\nexport const UNEXPECTED_PK_LEN_ERROR_MSG =\r\n  'nacl public key length is not 32 bytes';\r\n\r\n/**\r\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\r\n * @param address - an Algorand address with checksum.\r\n * @returns the decoded form of the address's public key and checksum\r\n */\r\nexport function decodeAddress(address: string): Address {\r\n  if (typeof address !== 'string' || address.length !== ALGORAND_ADDRESS_LENGTH)\r\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\r\n\r\n  // try to decode\r\n  const decoded = base32.decode.asBytes(address.toString());\r\n  // Sanity check\r\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)\r\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\r\n\r\n  // Find publickey and checksum\r\n  const pk = new Uint8Array(\r\n    decoded.slice(\r\n      0,\r\n      ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\r\n    )\r\n  );\r\n  const cs = new Uint8Array(\r\n    decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH)\r\n  );\r\n\r\n  // Compute checksum\r\n  const checksum = nacl\r\n    .genericHash(pk)\r\n    .slice(\r\n      nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\r\n      nacl.HASH_BYTES_LENGTH\r\n    );\r\n\r\n  // Check if the checksum and the address are equal\r\n  if (!utils.arrayEqual(checksum, cs))\r\n    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\r\n\r\n  return { publicKey: pk, checksum: cs };\r\n}\r\n\r\n/**\r\n * isValidAddress checks if a string is a valid Algorand address.\r\n * @param address - an Algorand address with checksum.\r\n * @returns true if valid, false otherwise\r\n */\r\nexport function isValidAddress(address: string) {\r\n  // Try to decode\r\n  try {\r\n    decodeAddress(address);\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\r\n * @param address - a raw Algorand address\r\n * @returns the address and checksum encoded as a string.\r\n */\r\nexport function encodeAddress(address: Uint8Array) {\r\n  // compute checksum\r\n  const checksum = nacl\r\n    .genericHash(address)\r\n    .slice(\r\n      nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\r\n      nacl.PUBLIC_KEY_LENGTH\r\n    );\r\n  const addr = base32.encode(utils.concatArrays(address, checksum));\r\n\r\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\r\n}\r\n\r\n/**\r\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\r\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\r\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\r\n * Encoding this output yields a human readable address.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param pks - array of typed array public keys\r\n */\r\nexport function fromMultisigPreImg({\r\n  version,\r\n  threshold,\r\n  pks,\r\n}: Omit<MultisigMetadata, 'addrs'> & {\r\n  pks: Uint8Array[];\r\n}) {\r\n  if (version !== 1 || version > 255 || version < 0) {\r\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\r\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\r\n  }\r\n  if (\r\n    threshold === 0 ||\r\n    pks.length === 0 ||\r\n    threshold > pks.length ||\r\n    threshold > 255\r\n  ) {\r\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\r\n  }\r\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\r\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\r\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\r\n  }\r\n  const merged = new Uint8Array(\r\n    MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length\r\n  );\r\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\r\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\r\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\r\n  for (let i = 0; i < pks.length; i++) {\r\n    if (pks[i].length !== pkLen) {\r\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\r\n    }\r\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\r\n  }\r\n  return new Uint8Array(nacl.genericHash(merged));\r\n}\r\n\r\n/**\r\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\r\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\r\n * @param version - multisig version\r\n * @param threshold - multisig threshold\r\n * @param addrs - array of encoded addresses\r\n */\r\nexport function fromMultisigPreImgAddrs({\r\n  version,\r\n  threshold,\r\n  addrs,\r\n}: {\r\n  version: number;\r\n  threshold: number;\r\n  addrs: string[];\r\n}) {\r\n  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);\r\n  return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));\r\n}\r\n\r\n/**\r\n * Get the escrow address of an application.\r\n * @param appID - The ID of the application.\r\n * @returns The address corresponding to that application's escrow account.\r\n */\r\nexport function getApplicationAddress(appID: number | bigint): string {\r\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\r\n  const hash = nacl.genericHash(toBeSigned);\r\n  return encodeAddress(new Uint8Array(hash));\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,OAAOC,MAAM,MAAM,WAAW;AAC9B,OAAO,KAAKC,IAAI,MAAM,sBAAsB;AAC5C,OAAO,KAAKC,KAAK,MAAM,gBAAgB;AACvC,SAASC,YAAY,QAAQ,UAAU;AAIvC,MAAMC,4BAA4B,GAAG,EAAE;AACvC,MAAMC,6BAA6B,GAAG,CAAC;AACvC,MAAMC,uBAAuB,GAAG,EAAE;AAClC,OAAO,MAAMC,4BAA4B,GACvC,4DAA4D;AAE9D;AACA,MAAMC,2BAA2B,GAAG,IAAIC,UAAU,CAAC,CACjD,EAAE,EACF,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,EAAE,EACF,GAAG,EACH,GAAG,EACH,GAAG,CACJ,CAAC;AAEF,MAAMC,aAAa,GAAGX,MAAM,CAACY,IAAI,CAAC,OAAO,CAAC;AAE1C,OAAO,MAAMC,2BAA2B,GAAG,+BAA+B;AAC1E,OAAO,MAAMC,0BAA0B,GAAG,4BAA4B;AACtE,OAAO,MAAMC,8BAA8B,GAAG,0BAA0B;AACxE,OAAO,MAAMC,gCAAgC,GAAG,wBAAwB;AACxE,OAAO,MAAMC,yBAAyB,GACpC,wCAAwC;AAC1C,OAAO,MAAMC,2BAA2B,GACtC,wCAAwC;AAE1C;;;;;AAKA,OAAM,SAAUC,aAAaA,CAACC,OAAe;EAC3C,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAACC,MAAM,KAAKd,uBAAuB,EAC3E,MAAM,IAAIe,KAAK,CAACT,2BAA2B,CAAC;EAE9C;EACA,MAAMU,OAAO,GAAGtB,MAAM,CAACuB,MAAM,CAACC,OAAO,CAACL,OAAO,CAACM,QAAQ,EAAE,CAAC;EACzD;EACA,IAAIH,OAAO,CAACF,MAAM,KAAKhB,4BAA4B,EACjD,MAAM,IAAIiB,KAAK,CAACT,2BAA2B,CAAC;EAE9C;EACA,MAAMc,EAAE,GAAG,IAAIjB,UAAU,CACvBa,OAAO,CAACK,KAAK,CACX,CAAC,EACDvB,4BAA4B,GAAGC,6BAA6B,CAC7D,CACF;EACD,MAAMuB,EAAE,GAAG,IAAInB,UAAU,CACvBa,OAAO,CAACK,KAAK,CAAC1B,IAAI,CAAC4B,iBAAiB,EAAEzB,4BAA4B,CAAC,CACpE;EAED;EACA,MAAM0B,QAAQ,GAAG7B,IAAI,CAClB8B,WAAW,CAACL,EAAE,CAAC,CACfC,KAAK,CACJ1B,IAAI,CAAC+B,iBAAiB,GAAG3B,6BAA6B,EACtDJ,IAAI,CAAC+B,iBAAiB,CACvB;EAEH;EACA,IAAI,CAAC9B,KAAK,CAAC+B,UAAU,CAACH,QAAQ,EAAEF,EAAE,CAAC,EACjC,MAAM,IAAIP,KAAK,CAACR,0BAA0B,CAAC;EAE7C,OAAO;IAAEqB,SAAS,EAAER,EAAE;IAAEI,QAAQ,EAAEF;EAAE,CAAE;AACxC;AAEA;;;;;AAKA,OAAM,SAAUO,cAAcA,CAAChB,OAAe;EAC5C;EACA,IAAI;IACFD,aAAa,CAACC,OAAO,CAAC;GACvB,CAAC,OAAOiB,CAAC,EAAE;IACV,OAAO,KAAK;;EAEd,OAAO,IAAI;AACb;AAEA;;;;;AAKA,OAAM,SAAUC,aAAaA,CAAClB,OAAmB;EAC/C;EACA,MAAMW,QAAQ,GAAG7B,IAAI,CAClB8B,WAAW,CAACZ,OAAO,CAAC,CACpBQ,KAAK,CACJ1B,IAAI,CAAC4B,iBAAiB,GAAGxB,6BAA6B,EACtDJ,IAAI,CAAC4B,iBAAiB,CACvB;EACH,MAAMS,IAAI,GAAGtC,MAAM,CAACuC,MAAM,CAACrC,KAAK,CAACsC,YAAY,CAACrB,OAAO,EAAEW,QAAQ,CAAC,CAAC;EAEjE,OAAOQ,IAAI,CAACb,QAAQ,EAAE,CAACE,KAAK,CAAC,CAAC,EAAErB,uBAAuB,CAAC,CAAC,CAAC;AAC5D;AAEA;;;;;;;;;AASA,OAAM,SAAUmC,kBAAkBA,CAAC;EACjCC,OAAO;EACPC,SAAS;EACTC;AAAG,CAGJ;EACC,IAAIF,OAAO,KAAK,CAAC,IAAIA,OAAO,GAAG,GAAG,IAAIA,OAAO,GAAG,CAAC,EAAE;IACjD;IACA,MAAM,IAAIrB,KAAK,CAACP,8BAA8B,CAAC;;EAEjD,IACE6B,SAAS,KAAK,CAAC,IACfC,GAAG,CAACxB,MAAM,KAAK,CAAC,IAChBuB,SAAS,GAAGC,GAAG,CAACxB,MAAM,IACtBuB,SAAS,GAAG,GAAG,EACf;IACA,MAAM,IAAItB,KAAK,CAACN,gCAAgC,CAAC;;EAEnD,MAAM8B,KAAK,GAAGzC,4BAA4B,GAAGC,6BAA6B;EAC1E,IAAIwC,KAAK,KAAK5C,IAAI,CAAC4B,iBAAiB,EAAE;IACpC,MAAM,IAAIR,KAAK,CAACJ,2BAA2B,CAAC;;EAE9C,MAAM6B,MAAM,GAAG,IAAIrC,UAAU,CAC3BD,2BAA2B,CAACY,MAAM,GAAG,CAAC,GAAGyB,KAAK,GAAGD,GAAG,CAACxB,MAAM,CAC5D;EACD0B,MAAM,CAACC,GAAG,CAACvC,2BAA2B,EAAE,CAAC,CAAC;EAC1CsC,MAAM,CAACC,GAAG,CAAC,CAACL,OAAO,CAAC,EAAElC,2BAA2B,CAACY,MAAM,CAAC;EACzD0B,MAAM,CAACC,GAAG,CAAC,CAACJ,SAAS,CAAC,EAAEnC,2BAA2B,CAACY,MAAM,GAAG,CAAC,CAAC;EAC/D,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACxB,MAAM,EAAE4B,CAAC,EAAE,EAAE;IACnC,IAAIJ,GAAG,CAACI,CAAC,CAAC,CAAC5B,MAAM,KAAKyB,KAAK,EAAE;MAC3B,MAAM,IAAIxB,KAAK,CAACL,yBAAyB,CAAC;;IAE5C8B,MAAM,CAACC,GAAG,CAACH,GAAG,CAACI,CAAC,CAAC,EAAExC,2BAA2B,CAACY,MAAM,GAAG,CAAC,GAAG4B,CAAC,GAAGH,KAAK,CAAC;;EAExE,OAAO,IAAIpC,UAAU,CAACR,IAAI,CAAC8B,WAAW,CAACe,MAAM,CAAC,CAAC;AACjD;AAEA;;;;;;;AAOA,OAAM,SAAUG,uBAAuBA,CAAC;EACtCP,OAAO;EACPC,SAAS;EACTO;AAAK,CAKN;EACC,MAAMN,GAAG,GAAGM,KAAK,CAACC,GAAG,CAAEb,IAAI,IAAKpB,aAAa,CAACoB,IAAI,CAAC,CAACJ,SAAS,CAAC;EAC9D,OAAOG,aAAa,CAACI,kBAAkB,CAAC;IAAEC,OAAO;IAAEC,SAAS;IAAEC;EAAG,CAAE,CAAC,CAAC;AACvE;AAEA;;;;;AAKA,OAAM,SAAUQ,qBAAqBA,CAACC,KAAsB;EAC1D,MAAMC,UAAU,GAAGpD,KAAK,CAACsC,YAAY,CAAC9B,aAAa,EAAEP,YAAY,CAACkD,KAAK,CAAC,CAAC;EACzE,MAAME,IAAI,GAAGtD,IAAI,CAAC8B,WAAW,CAACuB,UAAU,CAAC;EACzC,OAAOjB,aAAa,CAAC,IAAI5B,UAAU,CAAC8C,IAAI,CAAC,CAAC;AAC5C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}