{"ast":null,"code":"import { Buffer } from 'buffer';\n/**\r\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\r\n * @param bi - The bigint to convert.\r\n * @param size - The size of the resulting byte array.\r\n * @returns A byte array containing the big-endian encoding of the input bigint\r\n */\nexport function bigIntToBytes(bi, size) {\n  let hex = bi.toString(16);\n  // Pad the hex with zeros so it matches the size in bytes\n  if (hex.length !== size * 2) {\n    hex = hex.padStart(size * 2, '0');\n  }\n  const byteArray = new Uint8Array(hex.length / 2);\n  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return byteArray;\n}\n/**\r\n * bytesToBigInt produces a bigint from a binary representation.\r\n *\r\n * @param bytes - The Uint8Array to convert.\r\n * @returns The bigint that was encoded in the input data.\r\n */\nexport function bytesToBigInt(bytes) {\n  let res = BigInt(0);\n  const buf = Buffer.from(bytes);\n  for (let i = 0; i < bytes.length; i++) {\n    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);\n  }\n  return res;\n}","map":{"version":3,"names":["Buffer","bigIntToBytes","bi","size","hex","toString","length","padStart","byteArray","Uint8Array","i","j","parseInt","slice","bytesToBigInt","bytes","res","BigInt","buf","from","Number","readUIntBE"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\encoding\\bigint.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\n\r\n/**\r\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\r\n * @param bi - The bigint to convert.\r\n * @param size - The size of the resulting byte array.\r\n * @returns A byte array containing the big-endian encoding of the input bigint\r\n */\r\nexport function bigIntToBytes(bi: bigint | number, size: number) {\r\n  let hex = bi.toString(16);\r\n  // Pad the hex with zeros so it matches the size in bytes\r\n  if (hex.length !== size * 2) {\r\n    hex = hex.padStart(size * 2, '0');\r\n  }\r\n  const byteArray = new Uint8Array(hex.length / 2);\r\n  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\r\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\r\n  }\r\n  return byteArray;\r\n}\r\n\r\n/**\r\n * bytesToBigInt produces a bigint from a binary representation.\r\n *\r\n * @param bytes - The Uint8Array to convert.\r\n * @returns The bigint that was encoded in the input data.\r\n */\r\nexport function bytesToBigInt(bytes: Uint8Array) {\r\n  let res = BigInt(0);\r\n  const buf = Buffer.from(bytes);\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);\r\n  }\r\n  return res;\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAE/B;;;;;;AAMA,OAAM,SAAUC,aAAaA,CAACC,EAAmB,EAAEC,IAAY;EAC7D,IAAIC,GAAG,GAAGF,EAAE,CAACG,QAAQ,CAAC,EAAE,CAAC;EACzB;EACA,IAAID,GAAG,CAACE,MAAM,KAAKH,IAAI,GAAG,CAAC,EAAE;IAC3BC,GAAG,GAAGA,GAAG,CAACG,QAAQ,CAACJ,IAAI,GAAG,CAAC,EAAE,GAAG,CAAC;;EAEnC,MAAMK,SAAS,GAAG,IAAIC,UAAU,CAACL,GAAG,CAACE,MAAM,GAAG,CAAC,CAAC;EAChD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGN,GAAG,CAACE,MAAM,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAEC,CAAC,IAAI,CAAC,EAAE;IACtDH,SAAS,CAACE,CAAC,CAAC,GAAGE,QAAQ,CAACR,GAAG,CAACS,KAAK,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;;EAElD,OAAOH,SAAS;AAClB;AAEA;;;;;;AAMA,OAAM,SAAUM,aAAaA,CAACC,KAAiB;EAC7C,IAAIC,GAAG,GAAGC,MAAM,CAAC,CAAC,CAAC;EACnB,MAAMC,GAAG,GAAGlB,MAAM,CAACmB,IAAI,CAACJ,KAAK,CAAC;EAC9B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,KAAK,CAACT,MAAM,EAAEI,CAAC,EAAE,EAAE;IACrCM,GAAG,GAAGC,MAAM,CAACG,MAAM,CAACF,GAAG,CAACG,UAAU,CAACX,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAGM,GAAG,GAAGC,MAAM,CAAC,GAAG,CAAC;;EAEhE,OAAOD,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}