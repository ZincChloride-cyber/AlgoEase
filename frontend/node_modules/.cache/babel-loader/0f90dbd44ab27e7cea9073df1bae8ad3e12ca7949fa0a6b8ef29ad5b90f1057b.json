{"ast":null,"code":"import { Buffer } from 'buffer';\nimport ServiceClient from './v2/serviceClient';\nimport * as txn from '../transaction';\nexport default class Kmd extends ServiceClient {\n  constructor(token, baseServer = 'http://127.0.0.1', port = 7833, headers = {}) {\n    super('X-KMD-API-Token', token, baseServer, port, headers);\n  }\n  /**\r\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\r\n   */\n  async versions() {\n    const res = await this.c.get('/versions');\n    return res.body;\n  }\n  /**\r\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\r\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\r\n   */\n  async listWallets() {\n    const res = await this.c.get('/v1/wallets');\n    return res.body;\n  }\n  /**\r\n   * createWallet creates a wallet with the specified name, password, driver,\r\n   * and master derivation key. If the master derivation key is blank, one is\r\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\r\n   * containing information about the new wallet.\r\n   * @param walletName\r\n   * @param walletPassword\r\n   * @param walletDriverName\r\n   * @param walletMDK\r\n   */\n  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = 'sqlite') {\n    const req = {\n      wallet_name: walletName,\n      wallet_driver_name: walletDriverName,\n      wallet_password: walletPassword,\n      master_derivation_key: Buffer.from(walletMDK).toString('base64')\n    };\n    const res = await this.c.post('/v1/wallet', req);\n    return res.body;\n  }\n  /**\r\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\r\n   * initWalletHandleResponse containing a wallet handle token. This wallet\r\n   * handle token can be used for subsequent operations on this wallet, like key\r\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\r\n   * configurable number of seconds, and must be renewed periodically with\r\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\r\n   * you're done interacting with this wallet.\r\n   * @param walletID\r\n   * @param walletPassword\r\n   */\n  async initWalletHandle(walletID, walletPassword) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword\n    };\n    const res = await this.c.post('/v1/wallet/init', req);\n    return res.body;\n  }\n  /**\r\n   * releaseWalletHandle invalidates the passed wallet handle token, making\r\n   * it unusuable for subsequent wallet operations.\r\n   * @param walletHandle\r\n   */\n  async releaseWalletHandle(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await this.c.post('/v1/wallet/release', req);\n    return res.body;\n  }\n  /**\r\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\r\n   * the expiration time to some number of seconds in the future. It returns a\r\n   * RenewWalletHandleResponse containing the walletHandle and the number of\r\n   * seconds until expiration\r\n   * @param walletHandle\r\n   */\n  async renewWalletHandle(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await this.c.post('/v1/wallet/renew', req);\n    return res.body;\n  }\n  /**\r\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\r\n   * and renames the underlying wallet.\r\n   * @param walletID\r\n   * @param walletPassword\r\n   * @param newWalletName\r\n   */\n  async renameWallet(walletID, walletPassword, newWalletName) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n      wallet_name: newWalletName\n    };\n    const res = await this.c.post('/v1/wallet/rename', req);\n    return res.body;\n  }\n  /**\r\n   * getWallet accepts a wallet handle and returns high level information about\r\n   * this wallet in a GetWalletResponse.\r\n   * @param walletHandle\r\n   */\n  async getWallet(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await this.c.post('/v1/wallet/info', req);\n    return res.body;\n  }\n  /**\r\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\r\n   * returns an ExportMasterDerivationKeyResponse containing the master\r\n   * derivation key. This key can be used as an argument to CreateWallet in\r\n   * order to recover the keys generated by this wallet. The master derivation\r\n   * key can be encoded as a sequence of words using the mnemonic library, and\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   */\n  async exportMasterDerivationKey(walletHandle, walletPassword) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword\n    };\n    const res = await this.c.post('/v1/master-key/export', req);\n    return {\n      master_derivation_key: Buffer.from(res.body.master_derivation_key, 'base64')\n    };\n  }\n  /**\r\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\r\n   * the key into the wallet. It returns an ImportKeyResponse containing the\r\n   * address corresponding to this private key.\r\n   * @param walletHandle\r\n   * @param secretKey\r\n   */\n  async importKey(walletHandle, secretKey) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      private_key: Buffer.from(secretKey).toString('base64')\n    };\n    const res = await this.c.post('/v1/key/import', req);\n    return res.body;\n  }\n  /**\r\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\r\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\r\n   * address stored in the wallet.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\n  async exportKey(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await this.c.post('/v1/key/export', req);\n    return {\n      private_key: Buffer.from(res.body.private_key, 'base64')\n    };\n  }\n  /**\r\n   * generateKey accepts a wallet handle, and then generates the next key in the\r\n   * wallet using its internal master derivation key. Two wallets with the same\r\n   * master derivation key will generate the same sequence of keys.\r\n   * @param walletHandle\r\n   */\n  async generateKey(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      display_mnemonic: false\n    };\n    const res = await this.c.post('/v1/key', req);\n    return res.body;\n  }\n  /**\r\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\r\n   * the information about this address from the wallet (including address and\r\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\r\n   * the same key will not be generated again. However, if a wallet is recovered\r\n   * using the master derivation key, a key generated in this way can be\r\n   * recovered.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\n  async deleteKey(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await this.c.delete('/v1/key', req);\n    return res.body;\n  }\n  /**\r\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\r\n   * all of the addresses for which this wallet contains secret keys.\r\n   * @param walletHandle\r\n   */\n  async listKeys(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await this.c.post('/v1/key/list', req);\n    return res.body;\n  }\n  /**\r\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\r\n   * and returns and SignTransactionResponse containing an encoded, signed\r\n   * transaction. The transaction is signed using the key corresponding to the\r\n   * Sender field.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param transaction\r\n   */\n  async signTransaction(walletHandle, walletPassword, transaction) {\n    const tx = txn.instantiateTxnIfNeeded(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64')\n    };\n    const res = await this.c.post('/v1/transaction/sign', req);\n    if (res.status === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n    return res.body;\n  }\n  /**\r\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\r\n   * and returns and SignTransactionResponse containing an encoded, signed\r\n   * transaction. The transaction is signed using the key corresponding to the\r\n   * publicKey arg.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param transaction\r\n   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\r\n   */\n  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {\n    const tx = txn.instantiateTxnIfNeeded(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(publicKey).toString('base64')\n    };\n    const res = await this.c.post('/v1/transaction/sign', req);\n    if (res.status === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n    return res.body;\n  }\n  /**\r\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\r\n   * containing the multisig addresses whose preimages are stored in this wallet.\r\n   * A preimage is the information needed to reconstruct this multisig address,\r\n   * including multisig version information, threshold information, and a list\r\n   * of public keys.\r\n   * @param walletHandle\r\n   */\n  async listMultisig(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await this.c.post('/v1/multisig/list', req);\n    return res.body;\n  }\n  /**\r\n   * importMultisig accepts a wallet handle and the information required to\r\n   * generate a multisig address. It derives this address, and stores all of the\r\n   * information within the wallet. It returns a ImportMultisigResponse with the\r\n   * derived address.\r\n   * @param walletHandle\r\n   * @param version\r\n   * @param threshold\r\n   * @param pks\r\n   */\n  async importMultisig(walletHandle, version, threshold, pks) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      multisig_version: version,\n      threshold,\n      pks\n    };\n    const res = await this.c.post('/v1/multisig/import', req);\n    return res.body;\n  }\n  /**\r\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\r\n   * address, and returns an ExportMultisigResponse containing the stored\r\n   * multisig preimage. The preimage contains all of the information necessary\r\n   * to derive the multisig address, including version, threshold, and a list of\r\n   * public keys.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\n  async exportMultisig(walletHandle, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr\n    };\n    const res = await this.c.post('/v1/multisig/export', req);\n    return res.body;\n  }\n  /**\r\n   * signMultisigTransaction accepts a wallet handle, wallet password,\r\n   * transaction, public key (*not* an address), and an optional partial\r\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\r\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\r\n   * signature by the secret key included.\r\n   * @param walletHandle\r\n   * @param pw\r\n   * @param tx\r\n   * @param pk\r\n   * @param partial\r\n   */\n  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {\n    const tx = txn.instantiateTxnIfNeeded(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(pk).toString('base64'),\n      partial_multisig: partial,\n      wallet_password: pw\n    };\n    const res = await this.c.post('/v1/multisig/sign', req);\n    return res.body;\n  }\n  /**\r\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\r\n   * address, and deletes the information about this multisig address from the\r\n   * wallet (including address and secret key).\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\n  async deleteMultisig(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await this.c.delete('/v1/multisig', req);\n    return res.body;\n  }\n}","map":{"version":3,"names":["Buffer","ServiceClient","txn","Kmd","constructor","token","baseServer","port","headers","versions","res","c","get","body","listWallets","createWallet","walletName","walletPassword","walletMDK","Uint8Array","walletDriverName","req","wallet_name","wallet_driver_name","wallet_password","master_derivation_key","from","toString","post","initWalletHandle","walletID","wallet_id","releaseWalletHandle","walletHandle","wallet_handle_token","renewWalletHandle","renameWallet","newWalletName","getWallet","exportMasterDerivationKey","importKey","secretKey","private_key","exportKey","addr","address","generateKey","display_mnemonic","deleteKey","delete","listKeys","signTransaction","transaction","tx","instantiateTxnIfNeeded","toByte","status","signed_transaction","signTransactionWithSpecificPublicKey","publicKey","public_key","listMultisig","importMultisig","version","threshold","pks","multisig_version","exportMultisig","signMultisigTransaction","pw","pk","partial","partial_multisig","deleteMultisig"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\client\\kmd.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport ServiceClient from './v2/serviceClient';\r\nimport * as txn from '../transaction';\r\nimport { CustomTokenHeader, KMDTokenHeader } from './urlTokenBaseHTTPClient';\r\n\r\nexport default class Kmd extends ServiceClient {\r\n  constructor(\r\n    token: string | KMDTokenHeader | CustomTokenHeader,\r\n    baseServer = 'http://127.0.0.1',\r\n    port: string | number = 7833,\r\n    headers = {}\r\n  ) {\r\n    super('X-KMD-API-Token', token, baseServer, port, headers);\r\n  }\r\n\r\n  /**\r\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\r\n   */\r\n  async versions() {\r\n    const res = await this.c.get('/versions');\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\r\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\r\n   */\r\n  async listWallets() {\r\n    const res = await this.c.get('/v1/wallets');\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * createWallet creates a wallet with the specified name, password, driver,\r\n   * and master derivation key. If the master derivation key is blank, one is\r\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\r\n   * containing information about the new wallet.\r\n   * @param walletName\r\n   * @param walletPassword\r\n   * @param walletDriverName\r\n   * @param walletMDK\r\n   */\r\n  async createWallet(\r\n    walletName: string,\r\n    walletPassword: string,\r\n    walletMDK: Uint8Array = new Uint8Array(),\r\n    walletDriverName = 'sqlite'\r\n  ) {\r\n    const req = {\r\n      wallet_name: walletName,\r\n      wallet_driver_name: walletDriverName,\r\n      wallet_password: walletPassword,\r\n      master_derivation_key: Buffer.from(walletMDK).toString('base64'),\r\n    };\r\n    const res = await this.c.post('/v1/wallet', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\r\n   * initWalletHandleResponse containing a wallet handle token. This wallet\r\n   * handle token can be used for subsequent operations on this wallet, like key\r\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\r\n   * configurable number of seconds, and must be renewed periodically with\r\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\r\n   * you're done interacting with this wallet.\r\n   * @param walletID\r\n   * @param walletPassword\r\n   */\r\n  async initWalletHandle(walletID: string, walletPassword: string) {\r\n    const req = {\r\n      wallet_id: walletID,\r\n      wallet_password: walletPassword,\r\n    };\r\n    const res = await this.c.post('/v1/wallet/init', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * releaseWalletHandle invalidates the passed wallet handle token, making\r\n   * it unusuable for subsequent wallet operations.\r\n   * @param walletHandle\r\n   */\r\n  async releaseWalletHandle(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n    };\r\n    const res = await this.c.post('/v1/wallet/release', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\r\n   * the expiration time to some number of seconds in the future. It returns a\r\n   * RenewWalletHandleResponse containing the walletHandle and the number of\r\n   * seconds until expiration\r\n   * @param walletHandle\r\n   */\r\n  async renewWalletHandle(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n    };\r\n    const res = await this.c.post('/v1/wallet/renew', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\r\n   * and renames the underlying wallet.\r\n   * @param walletID\r\n   * @param walletPassword\r\n   * @param newWalletName\r\n   */\r\n  async renameWallet(\r\n    walletID: string,\r\n    walletPassword: string,\r\n    newWalletName: string\r\n  ) {\r\n    const req = {\r\n      wallet_id: walletID,\r\n      wallet_password: walletPassword,\r\n      wallet_name: newWalletName,\r\n    };\r\n    const res = await this.c.post('/v1/wallet/rename', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * getWallet accepts a wallet handle and returns high level information about\r\n   * this wallet in a GetWalletResponse.\r\n   * @param walletHandle\r\n   */\r\n  async getWallet(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n    };\r\n    const res = await this.c.post('/v1/wallet/info', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\r\n   * returns an ExportMasterDerivationKeyResponse containing the master\r\n   * derivation key. This key can be used as an argument to CreateWallet in\r\n   * order to recover the keys generated by this wallet. The master derivation\r\n   * key can be encoded as a sequence of words using the mnemonic library, and\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   */\r\n  async exportMasterDerivationKey(\r\n    walletHandle: string,\r\n    walletPassword: string\r\n  ) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      wallet_password: walletPassword,\r\n    };\r\n    const res = await this.c.post('/v1/master-key/export', req);\r\n    return {\r\n      master_derivation_key: Buffer.from(\r\n        res.body.master_derivation_key,\r\n        'base64'\r\n      ),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\r\n   * the key into the wallet. It returns an ImportKeyResponse containing the\r\n   * address corresponding to this private key.\r\n   * @param walletHandle\r\n   * @param secretKey\r\n   */\r\n  async importKey(walletHandle: string, secretKey: Uint8Array) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      private_key: Buffer.from(secretKey).toString('base64'),\r\n    };\r\n    const res = await this.c.post('/v1/key/import', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\r\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\r\n   * address stored in the wallet.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\r\n  async exportKey(walletHandle: string, walletPassword: string, addr: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      address: addr,\r\n      wallet_password: walletPassword,\r\n    };\r\n    const res = await this.c.post('/v1/key/export', req);\r\n    return { private_key: Buffer.from(res.body.private_key, 'base64') };\r\n  }\r\n\r\n  /**\r\n   * generateKey accepts a wallet handle, and then generates the next key in the\r\n   * wallet using its internal master derivation key. Two wallets with the same\r\n   * master derivation key will generate the same sequence of keys.\r\n   * @param walletHandle\r\n   */\r\n  async generateKey(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      display_mnemonic: false,\r\n    };\r\n    const res = await this.c.post('/v1/key', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\r\n   * the information about this address from the wallet (including address and\r\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\r\n   * the same key will not be generated again. However, if a wallet is recovered\r\n   * using the master derivation key, a key generated in this way can be\r\n   * recovered.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\r\n  async deleteKey(walletHandle: string, walletPassword: string, addr: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      address: addr,\r\n      wallet_password: walletPassword,\r\n    };\r\n    const res = await this.c.delete('/v1/key', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\r\n   * all of the addresses for which this wallet contains secret keys.\r\n   * @param walletHandle\r\n   */\r\n  async listKeys(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n    };\r\n    const res = await this.c.post('/v1/key/list', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\r\n   * and returns and SignTransactionResponse containing an encoded, signed\r\n   * transaction. The transaction is signed using the key corresponding to the\r\n   * Sender field.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param transaction\r\n   */\r\n  async signTransaction(\r\n    walletHandle: string,\r\n    walletPassword: string,\r\n    transaction: txn.TransactionLike\r\n  ) {\r\n    const tx = txn.instantiateTxnIfNeeded(transaction);\r\n\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      wallet_password: walletPassword,\r\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\r\n    };\r\n    const res = await this.c.post('/v1/transaction/sign', req);\r\n\r\n    if (res.status === 200) {\r\n      return Buffer.from(res.body.signed_transaction, 'base64');\r\n    }\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\r\n   * and returns and SignTransactionResponse containing an encoded, signed\r\n   * transaction. The transaction is signed using the key corresponding to the\r\n   * publicKey arg.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param transaction\r\n   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\r\n   */\r\n  async signTransactionWithSpecificPublicKey(\r\n    walletHandle: string,\r\n    walletPassword: string,\r\n    transaction: txn.TransactionLike,\r\n    publicKey: Uint8Array | string\r\n  ) {\r\n    const tx = txn.instantiateTxnIfNeeded(transaction);\r\n\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      wallet_password: walletPassword,\r\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\r\n      public_key: Buffer.from(publicKey).toString('base64'),\r\n    };\r\n    const res = await this.c.post('/v1/transaction/sign', req);\r\n\r\n    if (res.status === 200) {\r\n      return Buffer.from(res.body.signed_transaction, 'base64');\r\n    }\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\r\n   * containing the multisig addresses whose preimages are stored in this wallet.\r\n   * A preimage is the information needed to reconstruct this multisig address,\r\n   * including multisig version information, threshold information, and a list\r\n   * of public keys.\r\n   * @param walletHandle\r\n   */\r\n  async listMultisig(walletHandle: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n    };\r\n    const res = await this.c.post('/v1/multisig/list', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * importMultisig accepts a wallet handle and the information required to\r\n   * generate a multisig address. It derives this address, and stores all of the\r\n   * information within the wallet. It returns a ImportMultisigResponse with the\r\n   * derived address.\r\n   * @param walletHandle\r\n   * @param version\r\n   * @param threshold\r\n   * @param pks\r\n   */\r\n  async importMultisig(\r\n    walletHandle: string,\r\n    version: number,\r\n    threshold: number,\r\n    pks: string[]\r\n  ) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      multisig_version: version,\r\n      threshold,\r\n      pks,\r\n    };\r\n    const res = await this.c.post('/v1/multisig/import', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\r\n   * address, and returns an ExportMultisigResponse containing the stored\r\n   * multisig preimage. The preimage contains all of the information necessary\r\n   * to derive the multisig address, including version, threshold, and a list of\r\n   * public keys.\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\r\n  async exportMultisig(walletHandle: string, addr: string) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      address: addr,\r\n    };\r\n    const res = await this.c.post('/v1/multisig/export', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * signMultisigTransaction accepts a wallet handle, wallet password,\r\n   * transaction, public key (*not* an address), and an optional partial\r\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\r\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\r\n   * signature by the secret key included.\r\n   * @param walletHandle\r\n   * @param pw\r\n   * @param tx\r\n   * @param pk\r\n   * @param partial\r\n   */\r\n  async signMultisigTransaction(\r\n    walletHandle: string,\r\n    pw: string,\r\n    transaction: txn.TransactionLike,\r\n    pk: Uint8Array | string,\r\n    partial: string\r\n  ) {\r\n    const tx = txn.instantiateTxnIfNeeded(transaction);\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\r\n      public_key: Buffer.from(pk).toString('base64'),\r\n      partial_multisig: partial,\r\n      wallet_password: pw,\r\n    };\r\n    const res = await this.c.post('/v1/multisig/sign', req);\r\n    return res.body;\r\n  }\r\n\r\n  /**\r\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\r\n   * address, and deletes the information about this multisig address from the\r\n   * wallet (including address and secret key).\r\n   * @param walletHandle\r\n   * @param walletPassword\r\n   * @param addr\r\n   */\r\n  async deleteMultisig(\r\n    walletHandle: string,\r\n    walletPassword: string,\r\n    addr: string\r\n  ) {\r\n    const req = {\r\n      wallet_handle_token: walletHandle,\r\n      address: addr,\r\n      wallet_password: walletPassword,\r\n    };\r\n    const res = await this.c.delete('/v1/multisig', req);\r\n    return res.body;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}