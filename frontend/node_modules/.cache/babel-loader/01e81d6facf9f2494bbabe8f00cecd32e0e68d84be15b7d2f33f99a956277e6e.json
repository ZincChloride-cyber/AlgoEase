{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport Bid from './bid';\nimport * as convert from './convert';\nimport * as utils from './utils/utils';\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n// Errors\nexport const MULTISIG_BAD_SENDER_ERROR_MSG = 'The transaction sender address and multisig preimage do not match.';\n/**\r\n * signTransaction takes an object with either payment or key registration fields and\r\n * a secret key and returns a signed blob.\r\n *\r\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\r\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\r\n *\r\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\r\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\r\n *\r\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\r\n * @param txn - object with either payment or key registration fields\r\n * @param sk - Algorand Secret Key\r\n * @returns object contains the binary signed transaction and its txID\r\n */\nexport function signTransaction(txn, sk) {\n  if (typeof txn.from === 'undefined') {\n    // Get pk from sk if no sender specified\n    const key = nacl.keyPairFromSecretKey(sk);\n    // eslint-disable-next-line no-param-reassign\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return {\n    txID: algoTxn.txID().toString(),\n    blob: algoTxn.signTxn(sk)\n  };\n}\n/**\r\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\r\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\r\n * @param bid - Algorand Bid\r\n * @param sk - Algorand secret key\r\n * @returns Uint8Array binary signed bid\r\n */\nexport function signBid(bid, sk) {\n  const signedBid = new Bid(bid);\n  return signedBid.signBid(sk);\n}\n/**\r\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\r\n * with the private key, and returns the signature.\r\n * @param bytes - Uint8array\r\n * @param sk - Algorand secret key\r\n * @returns binary signature\r\n */\nexport function signBytes(bytes, sk) {\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\r\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\r\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\r\n * @param bytes - Uint8Array\r\n * @param signature - binary signature\r\n * @param addr - string address\r\n * @returns bool\r\n */\nexport function verifyBytes(bytes, signature, addr) {\n  const toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n/**\r\n * encodeObj takes a javascript object and returns its msgpack encoding\r\n * Note that the encoding sorts the fields alphabetically\r\n * @param o - js obj\r\n * @returns Uint8Array binary representation\r\n */\nexport function encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n/**\r\n * decodeObj takes a Uint8Array and returns its javascript obj\r\n * @param o - Uint8Array to decode\r\n * @returns object\r\n */\nexport function decodeObj(o) {\n  return encoding.decode(o);\n}\nexport const ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);\nexport const ERROR_INVALID_MICROALGOS = new Error(convert.INVALID_MICROALGOS_ERROR_MSG);\nexport { default as Algodv2 } from './client/v2/algod/algod';\nexport { default as Kmd } from './client/kmd';\nexport { default as IntDecoding } from './types/intDecoding';\nexport { default as Indexer } from './client/v2/indexer/indexer';\nexport { waitForConfirmation } from './wait';\nexport { isValidAddress, encodeAddress, decodeAddress, getApplicationAddress } from './encoding/address';\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint';\nexport { encodeUint64, decodeUint64 } from './encoding/uint64';\nexport { default as generateAccount } from './account';\nimport * as modelsv2_1 from './client/v2/algod/models/types';\nexport { modelsv2_1 as modelsv2 };\nimport * as indexerModels_1 from './client/v2/indexer/models/types';\nexport { indexerModels_1 as indexerModels };\nexport { mnemonicToMasterDerivationKey, masterDerivationKeyToMnemonic, secretKeyToMnemonic, mnemonicToSecretKey, seedFromMnemonic, mnemonicFromSeed } from './mnemonic/mnemonic';\nexport { microalgosToAlgos, algosToMicroalgos, INVALID_MICROALGOS_ERROR_MSG } from './convert';\nexport { computeGroupID, assignGroupID } from './group';\nexport { LogicSig, LogicSigAccount, signLogicSigTransaction, signLogicSigTransactionObject, logicSigFromByte, tealSign, tealSignFromProgram, verifyTealSign } from './logicsig';\nexport { signMultisigTransaction, mergeMultisigTransactions, appendSignMultisigTransaction, createMultisigTransaction, appendSignRawMultisigSignature, verifyMultisig, multisigAddress } from './multisig';\nexport { SourceMap } from './logic/sourcemap';\nexport * from './dryrun';\nexport * from './makeTxn';\nexport * from './transaction';\nexport * from './signer';\nexport * from './composer';\nexport * from './types';\nexport * from './abi';","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","Bid","convert","utils","SIGN_BYTES_PREFIX","from","MULTISIG_BAD_SENDER_ERROR_MSG","signTransaction","txn","sk","key","keyPairFromSecretKey","encodeAddress","publicKey","algoTxn","instantiateTxnIfNeeded","txID","toString","blob","signTxn","signBid","bid","signedBid","signBytes","bytes","toBeSigned","concatArrays","sig","sign","verifyBytes","signature","addr","toBeVerified","pk","decodeAddress","verify","encodeObj","o","Uint8Array","encode","decodeObj","decode","ERROR_MULTISIG_BAD_SENDER","Error","ERROR_INVALID_MICROALGOS","INVALID_MICROALGOS_ERROR_MSG","default","Algodv2","Kmd","IntDecoding","Indexer","waitForConfirmation","isValidAddress","getApplicationAddress","bytesToBigInt","bigIntToBytes","encodeUint64","decodeUint64","generateAccount","modelsv2","indexerModels","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","secretKeyToMnemonic","mnemonicToSecretKey","seedFromMnemonic","mnemonicFromSeed","microalgosToAlgos","algosToMicroalgos","computeGroupID","assignGroupID","LogicSig","LogicSigAccount","signLogicSigTransaction","signLogicSigTransactionObject","logicSigFromByte","tealSign","tealSignFromProgram","verifyTealSign","signMultisigTransaction","mergeMultisigTransactions","appendSignMultisigTransaction","createMultisigTransaction","appendSignRawMultisigSignature","verifyMultisig","multisigAddress","SourceMap"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\main.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport * as nacl from './nacl/naclWrappers';\r\nimport * as address from './encoding/address';\r\nimport * as encoding from './encoding/encoding';\r\nimport * as txnBuilder from './transaction';\r\nimport Bid, { BidOptions } from './bid';\r\nimport * as convert from './convert';\r\nimport * as utils from './utils/utils';\r\n\r\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\r\n\r\n// Errors\r\nexport const MULTISIG_BAD_SENDER_ERROR_MSG =\r\n  'The transaction sender address and multisig preimage do not match.';\r\n\r\n/**\r\n * signTransaction takes an object with either payment or key registration fields and\r\n * a secret key and returns a signed blob.\r\n *\r\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\r\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\r\n *\r\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\r\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\r\n *\r\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\r\n * @param txn - object with either payment or key registration fields\r\n * @param sk - Algorand Secret Key\r\n * @returns object contains the binary signed transaction and its txID\r\n */\r\nexport function signTransaction(\r\n  txn: txnBuilder.TransactionLike,\r\n  sk: Uint8Array\r\n) {\r\n  if (typeof txn.from === 'undefined') {\r\n    // Get pk from sk if no sender specified\r\n    const key = nacl.keyPairFromSecretKey(sk);\r\n    // eslint-disable-next-line no-param-reassign\r\n    txn.from = address.encodeAddress(key.publicKey);\r\n  }\r\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\r\n\r\n  return {\r\n    txID: algoTxn.txID().toString(),\r\n    blob: algoTxn.signTxn(sk),\r\n  };\r\n}\r\n\r\n/**\r\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\r\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\r\n * @param bid - Algorand Bid\r\n * @param sk - Algorand secret key\r\n * @returns Uint8Array binary signed bid\r\n */\r\nexport function signBid(bid: BidOptions, sk: Uint8Array) {\r\n  const signedBid = new Bid(bid);\r\n  return signedBid.signBid(sk);\r\n}\r\n\r\n/**\r\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\r\n * with the private key, and returns the signature.\r\n * @param bytes - Uint8array\r\n * @param sk - Algorand secret key\r\n * @returns binary signature\r\n */\r\nexport function signBytes(bytes: Uint8Array, sk: Uint8Array) {\r\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\r\n  const sig = nacl.sign(toBeSigned, sk);\r\n  return sig;\r\n}\r\n\r\n/**\r\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\r\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\r\n * @param bytes - Uint8Array\r\n * @param signature - binary signature\r\n * @param addr - string address\r\n * @returns bool\r\n */\r\nexport function verifyBytes(\r\n  bytes: Uint8Array,\r\n  signature: Uint8Array,\r\n  addr: string\r\n) {\r\n  const toBeVerified = Buffer.from(\r\n    utils.concatArrays(SIGN_BYTES_PREFIX, bytes)\r\n  );\r\n  const pk = address.decodeAddress(addr).publicKey;\r\n  return nacl.verify(toBeVerified, signature, pk);\r\n}\r\n\r\n/**\r\n * encodeObj takes a javascript object and returns its msgpack encoding\r\n * Note that the encoding sorts the fields alphabetically\r\n * @param o - js obj\r\n * @returns Uint8Array binary representation\r\n */\r\nexport function encodeObj(o: Record<string | number | symbol, any>) {\r\n  return new Uint8Array(encoding.encode(o));\r\n}\r\n\r\n/**\r\n * decodeObj takes a Uint8Array and returns its javascript obj\r\n * @param o - Uint8Array to decode\r\n * @returns object\r\n */\r\nexport function decodeObj(o: ArrayLike<number>) {\r\n  return encoding.decode(o);\r\n}\r\n\r\nexport const ERROR_MULTISIG_BAD_SENDER = new Error(\r\n  MULTISIG_BAD_SENDER_ERROR_MSG\r\n);\r\nexport const ERROR_INVALID_MICROALGOS = new Error(\r\n  convert.INVALID_MICROALGOS_ERROR_MSG\r\n);\r\n\r\nexport { default as Algodv2 } from './client/v2/algod/algod';\r\nexport { default as Kmd } from './client/kmd';\r\nexport { default as IntDecoding } from './types/intDecoding';\r\nexport { default as Account } from './types/account';\r\nexport { default as Indexer } from './client/v2/indexer/indexer';\r\nexport {\r\n  BaseHTTPClient,\r\n  BaseHTTPClientResponse,\r\n  BaseHTTPClientError,\r\n} from './client/baseHTTPClient';\r\nexport {\r\n  AlgodTokenHeader,\r\n  IndexerTokenHeader,\r\n  KMDTokenHeader,\r\n  CustomTokenHeader,\r\n  TokenHeader,\r\n} from './client/urlTokenBaseHTTPClient';\r\nexport { waitForConfirmation } from './wait';\r\nexport {\r\n  isValidAddress,\r\n  encodeAddress,\r\n  decodeAddress,\r\n  getApplicationAddress,\r\n} from './encoding/address';\r\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint';\r\nexport { encodeUint64, decodeUint64 } from './encoding/uint64';\r\nexport { default as generateAccount } from './account';\r\nexport * as modelsv2 from './client/v2/algod/models/types';\r\nexport * as indexerModels from './client/v2/indexer/models/types';\r\nexport {\r\n  mnemonicToMasterDerivationKey,\r\n  masterDerivationKeyToMnemonic,\r\n  secretKeyToMnemonic,\r\n  mnemonicToSecretKey,\r\n  seedFromMnemonic,\r\n  mnemonicFromSeed,\r\n} from './mnemonic/mnemonic';\r\nexport {\r\n  microalgosToAlgos,\r\n  algosToMicroalgos,\r\n  INVALID_MICROALGOS_ERROR_MSG,\r\n} from './convert';\r\nexport { computeGroupID, assignGroupID } from './group';\r\nexport {\r\n  LogicSig,\r\n  LogicSigAccount,\r\n  signLogicSigTransaction,\r\n  signLogicSigTransactionObject,\r\n  logicSigFromByte,\r\n  tealSign,\r\n  tealSignFromProgram,\r\n  verifyTealSign,\r\n} from './logicsig';\r\nexport {\r\n  signMultisigTransaction,\r\n  mergeMultisigTransactions,\r\n  appendSignMultisigTransaction,\r\n  createMultisigTransaction,\r\n  appendSignRawMultisigSignature,\r\n  verifyMultisig,\r\n  multisigAddress,\r\n} from './multisig';\r\nexport { SourceMap } from './logic/sourcemap';\r\n\r\nexport * from './dryrun';\r\nexport * from './makeTxn';\r\nexport * from './transaction';\r\nexport * from './signer';\r\nexport * from './composer';\r\nexport * from './types';\r\nexport * from './abi';\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}