{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as utils from '../utils/utils';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient';\n/**\r\n * Remove falsy values or values with a length of 0 from an object.\r\n */\nfunction removeFalsyOrEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n/**\r\n * Create a new object with lower-case keys\r\n * See https://codereview.stackexchange.com/a/162418\r\n * Used to ensure all headers are lower-case and to work more easily with them\r\n */\nfunction tolowerCaseKeys(o) {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n/**\r\n * getAcceptFormat returns the correct Accept header depending on the\r\n * requested format.\r\n */\nfunction getAcceptFormat(query) {\n  if (query !== undefined && Object.prototype.hasOwnProperty.call(query, 'format')) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n/**\r\n * HTTPClient is a wrapper around a BaseHTTPClient\r\n * It takes care of setting the proper \"Accept\" header and of\r\n * decoding the JSON outputs.\r\n */\nexport default class HTTPClient {\n  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);\n    } else {\n      this.bc = bcOrTokenHeader;\n    }\n  }\n  /**\r\n   * Parse JSON using either the built-in JSON.parse or utils.parseJSON\r\n   * depending on whether jsonOptions are provided or not\r\n   *\r\n   * @param text - JSON data\r\n   * @param status - Status of the response (used in case parseJSON fails)\r\n   * @param jsonOptions - Options object to use to decode JSON responses. See\r\n   *   utils.parseJSON for the options available.\r\n   */\n  static parseJSON(text, status, jsonOptions = {}) {\n    try {\n      if (Object.keys(jsonOptions).length === 0) {\n        return text && JSON.parse(text);\n      }\n      return text && utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err = err_;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n  /**\r\n   * Serialize the data according to the requestHeaders\r\n   * Assumes that requestHeaders contain a key \"content-type\"\r\n   * If the content-type is \"application/json\", data is JSON serialized\r\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\r\n   * or an Uint8Array\r\n   * @private\r\n   */\n  static serializeData(data, requestHeaders) {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new Uint8Array(Buffer.from(JSON.stringify(data)));\n    }\n    if (typeof data === 'string') {\n      return new Uint8Array(Buffer.from(data));\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error('provided data is neither a string nor a Uint8Array and content-type is not application/json');\n  }\n  /**\r\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\r\n   * Parse the body in\r\n   * Modifies in place res and return the result\r\n   */\n  static prepareResponse(res, format, parseBody, jsonOptions = {}) {\n    let {\n      body\n    } = res;\n    let text;\n    if (format !== 'application/msgpack') {\n      text = body && Buffer.from(body).toString() || '';\n    }\n    if (parseBody && format === 'application/json') {\n      body = HTTPClient.parseJSON(text, res.status, jsonOptions);\n    }\n    return {\n      ...res,\n      body,\n      text,\n      ok: Math.trunc(res.status / 100) === 2\n    };\n  }\n  /**\r\n   * Prepare an error with a response\r\n   * (the type of errors BaseHTTPClient are supposed to throw)\r\n   * by adding the status and preparing the internal response\r\n   * @private\r\n   */\n  static prepareResponseError(err) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(err.response, 'application/json', true);\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n  /**\r\n   * Send a GET request.\r\n   * @param relativePath - The path of the request.\r\n   * @param query - An object containing the query parameters of the request.\r\n   * @param requestHeaders - An object containing additional request headers to use.\r\n   * @param jsonOptions - Options object to use to decode JSON responses. See\r\n   *   utils.parseJSON for the options available.\r\n   * @param parseBody - An optional boolean indicating whether the response body should be parsed\r\n   *   or not.\r\n   * @returns Response object.\r\n   */\n  async get(relativePath, query, requestHeaders = {}, jsonOptions = {}, parseBody = true) {\n    const format = getAcceptFormat(query);\n    const fullHeaders = {\n      ...requestHeaders,\n      accept: format\n    };\n    try {\n      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);\n      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\r\n   * Send a POST request.\r\n   * If no content-type present, adds the header \"content-type: application/json\"\r\n   * and data is serialized in JSON (if not empty)\r\n   */\n  async post(relativePath, data, requestHeaders = {}, query, parseBody = true) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    try {\n      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);\n      return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\r\n   * Send a DELETE request.\r\n   * If no content-type present, adds the header \"content-type: application/json\"\r\n   * and data is serialized in JSON (if not empty)\r\n   */\n  async delete(relativePath, data, requestHeaders = {}, parseBody = true) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), undefined, fullHeaders);\n    return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n  }\n}","map":{"version":3,"names":["Buffer","utils","URLTokenBaseHTTPClient","removeFalsyOrEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","tolowerCaseKeys","o","keys","reduce","c","k","toLowerCase","getAcceptFormat","query","undefined","format","HTTPClient","constructor","bcOrTokenHeader","baseServer","port","defaultHeaders","bc","parseJSON","text","status","jsonOptions","JSON","parse","err_","err","rawResponse","statusCode","serializeData","data","requestHeaders","Uint8Array","from","stringify","Error","prepareResponse","res","parseBody","body","toString","ok","Math","trunc","prepareResponseError","response","get","relativePath","fullHeaders","accept","post","delete"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\client\\client.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport * as utils from '../utils/utils';\r\nimport {\r\n  BaseHTTPClient,\r\n  BaseHTTPClientResponse,\r\n  Query,\r\n} from './baseHTTPClient';\r\nimport { TokenHeader, URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient';\r\n\r\ninterface ErrorWithAdditionalInfo extends Error {\r\n  rawResponse: string | null;\r\n  statusCode: number;\r\n}\r\n\r\nexport interface HTTPClientResponse {\r\n  body: Uint8Array | any; // when content-type=JSON, body is a JSON object, otherwise it's a Uint8Array\r\n  text?: string;\r\n  headers: Record<string, string>;\r\n  status: number;\r\n  ok: boolean;\r\n}\r\n\r\n/**\r\n * Remove falsy values or values with a length of 0 from an object.\r\n */\r\nfunction removeFalsyOrEmpty(obj: Record<string, any>) {\r\n  for (const key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Create a new object with lower-case keys\r\n * See https://codereview.stackexchange.com/a/162418\r\n * Used to ensure all headers are lower-case and to work more easily with them\r\n */\r\nfunction tolowerCaseKeys(o: object): object {\r\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\r\n  return Object.keys(o).reduce((c, k) => ((c[k.toLowerCase()] = o[k]), c), {});\r\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\r\n}\r\n\r\n/**\r\n * getAcceptFormat returns the correct Accept header depending on the\r\n * requested format.\r\n */\r\nfunction getAcceptFormat(\r\n  query?: Query<'msgpack' | 'json'>\r\n): 'application/msgpack' | 'application/json' {\r\n  if (\r\n    query !== undefined &&\r\n    Object.prototype.hasOwnProperty.call(query, 'format')\r\n  ) {\r\n    switch (query.format) {\r\n      case 'msgpack':\r\n        return 'application/msgpack';\r\n      case 'json':\r\n      default:\r\n        return 'application/json';\r\n    }\r\n  } else return 'application/json';\r\n}\r\n\r\n/**\r\n * HTTPClient is a wrapper around a BaseHTTPClient\r\n * It takes care of setting the proper \"Accept\" header and of\r\n * decoding the JSON outputs.\r\n */\r\nexport default class HTTPClient {\r\n  private bc: BaseHTTPClient;\r\n\r\n  /**\r\n   * Construct an HTTPClient from a BaseHTTPClient\r\n   * @param bc - the BaseHTTPClient used\r\n   */\r\n  constructor(bc: BaseHTTPClient);\r\n  /**\r\n   * Construct an HTTPClient from a URL (baseServer+port) and a token\r\n   */\r\n  constructor(\r\n    tokenHeader: TokenHeader,\r\n    baseServer: string,\r\n    port?: string | number,\r\n    defaultHeaders?: Record<string, string>\r\n  );\r\n\r\n  constructor(\r\n    bcOrTokenHeader: BaseHTTPClient | TokenHeader,\r\n    baseServer?: string,\r\n    port?: string | number,\r\n    defaultHeaders: Record<string, string> = {}\r\n  ) {\r\n    if (baseServer !== undefined) {\r\n      this.bc = new URLTokenBaseHTTPClient(\r\n        bcOrTokenHeader as TokenHeader,\r\n        baseServer,\r\n        port,\r\n        defaultHeaders\r\n      );\r\n    } else {\r\n      this.bc = bcOrTokenHeader as BaseHTTPClient;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse JSON using either the built-in JSON.parse or utils.parseJSON\r\n   * depending on whether jsonOptions are provided or not\r\n   *\r\n   * @param text - JSON data\r\n   * @param status - Status of the response (used in case parseJSON fails)\r\n   * @param jsonOptions - Options object to use to decode JSON responses. See\r\n   *   utils.parseJSON for the options available.\r\n   */\r\n  public static parseJSON(\r\n    text: string,\r\n    status: number,\r\n    jsonOptions: utils.JSONOptions = {}\r\n  ) {\r\n    try {\r\n      if (Object.keys(jsonOptions).length === 0) {\r\n        return text && JSON.parse(text);\r\n      }\r\n      return text && utils.parseJSON(text, jsonOptions);\r\n    } catch (err_) {\r\n      const err: ErrorWithAdditionalInfo = err_;\r\n      // return the raw response if the response parsing fails\r\n      err.rawResponse = text || null;\r\n      // return the http status code if the response parsing fails\r\n      err.statusCode = status;\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serialize the data according to the requestHeaders\r\n   * Assumes that requestHeaders contain a key \"content-type\"\r\n   * If the content-type is \"application/json\", data is JSON serialized\r\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\r\n   * or an Uint8Array\r\n   * @private\r\n   */\r\n  private static serializeData(\r\n    data: object,\r\n    requestHeaders: Record<string, string>\r\n  ): Uint8Array {\r\n    if (!data) {\r\n      return new Uint8Array(0); // empty Uint8Array\r\n    }\r\n    if (requestHeaders['content-type'] === 'application/json') {\r\n      return new Uint8Array(Buffer.from(JSON.stringify(data)));\r\n    }\r\n    if (typeof data === 'string') {\r\n      return new Uint8Array(Buffer.from(data));\r\n    }\r\n    if (data instanceof Uint8Array) {\r\n      return data;\r\n    }\r\n    throw new Error(\r\n      'provided data is neither a string nor a Uint8Array and content-type is not application/json'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\r\n   * Parse the body in\r\n   * Modifies in place res and return the result\r\n   */\r\n  private static prepareResponse(\r\n    res: BaseHTTPClientResponse,\r\n    format: 'application/msgpack' | 'application/json',\r\n    parseBody: boolean,\r\n    jsonOptions: utils.JSONOptions = {}\r\n  ): HTTPClientResponse {\r\n    let { body } = res;\r\n    let text;\r\n\r\n    if (format !== 'application/msgpack') {\r\n      text = (body && Buffer.from(body).toString()) || '';\r\n    }\r\n\r\n    if (parseBody && format === 'application/json') {\r\n      body = HTTPClient.parseJSON(text, res.status, jsonOptions);\r\n    }\r\n\r\n    return {\r\n      ...res,\r\n      body,\r\n      text,\r\n      ok: Math.trunc(res.status / 100) === 2,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prepare an error with a response\r\n   * (the type of errors BaseHTTPClient are supposed to throw)\r\n   * by adding the status and preparing the internal response\r\n   * @private\r\n   */\r\n  private static prepareResponseError(err) {\r\n    if (err.response) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      err.response = HTTPClient.prepareResponse(\r\n        err.response,\r\n        'application/json',\r\n        true\r\n      );\r\n      // eslint-disable-next-line no-param-reassign\r\n      err.status = err.response.status;\r\n    }\r\n    return err;\r\n  }\r\n\r\n  /**\r\n   * Send a GET request.\r\n   * @param relativePath - The path of the request.\r\n   * @param query - An object containing the query parameters of the request.\r\n   * @param requestHeaders - An object containing additional request headers to use.\r\n   * @param jsonOptions - Options object to use to decode JSON responses. See\r\n   *   utils.parseJSON for the options available.\r\n   * @param parseBody - An optional boolean indicating whether the response body should be parsed\r\n   *   or not.\r\n   * @returns Response object.\r\n   */\r\n  async get(\r\n    relativePath: string,\r\n    query?: Query<any>,\r\n    requestHeaders: Record<string, string> = {},\r\n    jsonOptions: utils.JSONOptions = {},\r\n    parseBody: boolean = true\r\n  ): Promise<HTTPClientResponse> {\r\n    const format = getAcceptFormat(query);\r\n    const fullHeaders = { ...requestHeaders, accept: format };\r\n\r\n    try {\r\n      const res = await this.bc.get(\r\n        relativePath,\r\n        removeFalsyOrEmpty(query),\r\n        fullHeaders\r\n      );\r\n\r\n      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);\r\n    } catch (err) {\r\n      throw HTTPClient.prepareResponseError(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a POST request.\r\n   * If no content-type present, adds the header \"content-type: application/json\"\r\n   * and data is serialized in JSON (if not empty)\r\n   */\r\n  async post(\r\n    relativePath: string,\r\n    data: any,\r\n    requestHeaders: Record<string, string> = {},\r\n    query?: Query<any>,\r\n    parseBody: boolean = true\r\n  ): Promise<HTTPClientResponse> {\r\n    const fullHeaders = {\r\n      'content-type': 'application/json',\r\n      ...tolowerCaseKeys(requestHeaders),\r\n    };\r\n\r\n    try {\r\n      const res = await this.bc.post(\r\n        relativePath,\r\n        HTTPClient.serializeData(data, fullHeaders),\r\n        query,\r\n        fullHeaders\r\n      );\r\n\r\n      return HTTPClient.prepareResponse(res, 'application/json', parseBody);\r\n    } catch (err) {\r\n      throw HTTPClient.prepareResponseError(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a DELETE request.\r\n   * If no content-type present, adds the header \"content-type: application/json\"\r\n   * and data is serialized in JSON (if not empty)\r\n   */\r\n  async delete(\r\n    relativePath: string,\r\n    data: any,\r\n    requestHeaders: Record<string, string> = {},\r\n    parseBody: boolean = true\r\n  ) {\r\n    const fullHeaders = {\r\n      'content-type': 'application/json',\r\n      ...tolowerCaseKeys(requestHeaders),\r\n    };\r\n\r\n    const res = await this.bc.delete(\r\n      relativePath,\r\n      HTTPClient.serializeData(data, fullHeaders),\r\n      undefined,\r\n      fullHeaders\r\n    );\r\n\r\n    return HTTPClient.prepareResponse(res, 'application/json', parseBody);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}