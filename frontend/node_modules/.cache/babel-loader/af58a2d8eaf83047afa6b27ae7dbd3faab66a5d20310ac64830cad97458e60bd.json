{"ast":null,"code":"import { Buffer } from 'buffer';\n/**\r\n * Base class for models\r\n */\n/* eslint-disable no-underscore-dangle,camelcase */\nfunction _is_primitive(val) {\n  /* eslint-enable no-underscore-dangle,camelcase */\n  return val === undefined || val == null || typeof val !== 'object' && typeof val !== 'function';\n}\nfunction _get_obj_for_encoding(val, binary) {\n  /* eslint-enable no-underscore-dangle,camelcase,no-redeclare,no-unused-vars */\n  let targetPropValue;\n  if (val instanceof Uint8Array) {\n    targetPropValue = binary ? val : Buffer.from(val).toString('base64');\n  } else if (typeof val.get_obj_for_encoding === 'function') {\n    targetPropValue = val.get_obj_for_encoding(binary);\n  } else if (Array.isArray(val)) {\n    targetPropValue = [];\n    for (const elem of val) {\n      targetPropValue.push(_get_obj_for_encoding(elem, binary));\n    }\n  } else if (typeof val === 'object') {\n    const obj = {};\n    for (const prop of Object.keys(val)) {\n      obj[prop] = _get_obj_for_encoding(val[prop], binary);\n    }\n    targetPropValue = obj;\n  } else if (_is_primitive(val)) {\n    targetPropValue = val;\n  } else {\n    throw new Error(`Unsupported value: ${String(val)}`);\n  }\n  return targetPropValue;\n}\nexport default class BaseModel {\n  /**\r\n   * Get an object ready for encoding to either JSON or msgpack.\r\n   * @param binary - Use true to indicate that the encoding can handle raw binary objects\r\n   *   (Uint8Arrays). Use false to indicate that raw binary objects should be converted to base64\r\n   *   strings. True should be used for objects that will be encoded with msgpack, and false should\r\n   *   be used for objects that will be encoded with JSON.\r\n   */\n  get_obj_for_encoding(binary = false) {\n    /* eslint-enable no-underscore-dangle,camelcase */\n    const obj = {};\n    for (const prop of Object.keys(this.attribute_map)) {\n      const name = this.attribute_map[prop];\n      const value = this[prop];\n      if (typeof value !== 'undefined') {\n        obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);\n      }\n    }\n    return obj;\n  }\n}","map":{"version":3,"names":["Buffer","_is_primitive","val","undefined","_get_obj_for_encoding","binary","targetPropValue","Uint8Array","from","toString","get_obj_for_encoding","Array","isArray","elem","push","obj","prop","Object","keys","Error","String","BaseModel","attribute_map","name","value"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\client\\v2\\basemodel.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\n\r\n/**\r\n * Base class for models\r\n */\r\n\r\n/* eslint-disable no-underscore-dangle,camelcase */\r\nfunction _is_primitive(val: any): val is string | boolean | number | bigint {\r\n  /* eslint-enable no-underscore-dangle,camelcase */\r\n  return (\r\n    val === undefined ||\r\n    val == null ||\r\n    (typeof val !== 'object' && typeof val !== 'function')\r\n  );\r\n}\r\n\r\n/* eslint-disable no-underscore-dangle,camelcase,no-redeclare,no-unused-vars */\r\nfunction _get_obj_for_encoding(\r\n  val: Function,\r\n  binary: boolean\r\n): Record<string, any>;\r\nfunction _get_obj_for_encoding(val: any[], binary: boolean): any[];\r\nfunction _get_obj_for_encoding(\r\n  val: Record<string, any>,\r\n  binary: boolean\r\n): Record<string, any>;\r\nfunction _get_obj_for_encoding(val: any, binary: boolean): any {\r\n  /* eslint-enable no-underscore-dangle,camelcase,no-redeclare,no-unused-vars */\r\n  let targetPropValue: any;\r\n\r\n  if (val instanceof Uint8Array) {\r\n    targetPropValue = binary ? val : Buffer.from(val).toString('base64');\r\n  } else if (typeof val.get_obj_for_encoding === 'function') {\r\n    targetPropValue = val.get_obj_for_encoding(binary);\r\n  } else if (Array.isArray(val)) {\r\n    targetPropValue = [];\r\n    for (const elem of val) {\r\n      targetPropValue.push(_get_obj_for_encoding(elem, binary));\r\n    }\r\n  } else if (typeof val === 'object') {\r\n    const obj = {};\r\n    for (const prop of Object.keys(val)) {\r\n      obj[prop] = _get_obj_for_encoding(val[prop], binary);\r\n    }\r\n    targetPropValue = obj;\r\n  } else if (_is_primitive(val)) {\r\n    targetPropValue = val;\r\n  } else {\r\n    throw new Error(`Unsupported value: ${String(val)}`);\r\n  }\r\n  return targetPropValue;\r\n}\r\n\r\nexport default class BaseModel {\r\n  /* eslint-disable no-underscore-dangle,camelcase */\r\n  attribute_map: Record<string, string>;\r\n\r\n  /**\r\n   * Get an object ready for encoding to either JSON or msgpack.\r\n   * @param binary - Use true to indicate that the encoding can handle raw binary objects\r\n   *   (Uint8Arrays). Use false to indicate that raw binary objects should be converted to base64\r\n   *   strings. True should be used for objects that will be encoded with msgpack, and false should\r\n   *   be used for objects that will be encoded with JSON.\r\n   */\r\n  get_obj_for_encoding(binary = false) {\r\n    /* eslint-enable no-underscore-dangle,camelcase */\r\n    const obj: Record<string, any> = {};\r\n\r\n    for (const prop of Object.keys(this.attribute_map)) {\r\n      const name = this.attribute_map[prop];\r\n      const value = this[prop];\r\n\r\n      if (typeof value !== 'undefined') {\r\n        obj[name] =\r\n          value === null ? null : _get_obj_for_encoding(value, binary);\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAE/B;;;AAIA;AACA,SAASC,aAAaA,CAACC,GAAQ;EAC7B;EACA,OACEA,GAAG,KAAKC,SAAS,IACjBD,GAAG,IAAI,IAAI,IACV,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAW;AAE1D;AAYA,SAASE,qBAAqBA,CAACF,GAAQ,EAAEG,MAAe;EACtD;EACA,IAAIC,eAAoB;EAExB,IAAIJ,GAAG,YAAYK,UAAU,EAAE;IAC7BD,eAAe,GAAGD,MAAM,GAAGH,GAAG,GAAGF,MAAM,CAACQ,IAAI,CAACN,GAAG,CAAC,CAACO,QAAQ,CAAC,QAAQ,CAAC;GACrE,MAAM,IAAI,OAAOP,GAAG,CAACQ,oBAAoB,KAAK,UAAU,EAAE;IACzDJ,eAAe,GAAGJ,GAAG,CAACQ,oBAAoB,CAACL,MAAM,CAAC;GACnD,MAAM,IAAIM,KAAK,CAACC,OAAO,CAACV,GAAG,CAAC,EAAE;IAC7BI,eAAe,GAAG,EAAE;IACpB,KAAK,MAAMO,IAAI,IAAIX,GAAG,EAAE;MACtBI,eAAe,CAACQ,IAAI,CAACV,qBAAqB,CAACS,IAAI,EAAER,MAAM,CAAC,CAAC;;GAE5D,MAAM,IAAI,OAAOH,GAAG,KAAK,QAAQ,EAAE;IAClC,MAAMa,GAAG,GAAG,EAAE;IACd,KAAK,MAAMC,IAAI,IAAIC,MAAM,CAACC,IAAI,CAAChB,GAAG,CAAC,EAAE;MACnCa,GAAG,CAACC,IAAI,CAAC,GAAGZ,qBAAqB,CAACF,GAAG,CAACc,IAAI,CAAC,EAAEX,MAAM,CAAC;;IAEtDC,eAAe,GAAGS,GAAG;GACtB,MAAM,IAAId,aAAa,CAACC,GAAG,CAAC,EAAE;IAC7BI,eAAe,GAAGJ,GAAG;GACtB,MAAM;IACL,MAAM,IAAIiB,KAAK,CAAC,sBAAsBC,MAAM,CAAClB,GAAG,CAAC,EAAE,CAAC;;EAEtD,OAAOI,eAAe;AACxB;AAEA,eAAc,MAAOe,SAAS;EAI5B;;;;;;;EAOAX,oBAAoBA,CAACL,MAAM,GAAG,KAAK;IACjC;IACA,MAAMU,GAAG,GAAwB,EAAE;IAEnC,KAAK,MAAMC,IAAI,IAAIC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACI,aAAa,CAAC,EAAE;MAClD,MAAMC,IAAI,GAAG,IAAI,CAACD,aAAa,CAACN,IAAI,CAAC;MACrC,MAAMQ,KAAK,GAAG,IAAI,CAACR,IAAI,CAAC;MAExB,IAAI,OAAOQ,KAAK,KAAK,WAAW,EAAE;QAChCT,GAAG,CAACQ,IAAI,CAAC,GACPC,KAAK,KAAK,IAAI,GAAG,IAAI,GAAGpB,qBAAqB,CAACoB,KAAK,EAAEnB,MAAM,CAAC;;;IAIlE,OAAOU,GAAG;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}