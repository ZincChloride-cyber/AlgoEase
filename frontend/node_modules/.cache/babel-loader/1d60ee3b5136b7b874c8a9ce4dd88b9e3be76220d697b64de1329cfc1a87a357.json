{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport { verifyMultisig } from './multisig';\nimport * as utils from './utils/utils';\nimport * as txnBuilder from './transaction';\nimport { isValidAddress } from './encoding/address';\n/** sanityCheckProgram performs heuristic program validation:\r\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\r\n *\r\n * @param program - Program bytes to check\r\n */\nexport function sanityCheckProgram(program) {\n  if (!program || program.length === 0) throw new Error('empty program');\n  const lineBreakOrd = '\\n'.charCodeAt(0);\n  const blankSpaceOrd = ' '.charCodeAt(0);\n  const tildeOrd = '~'.charCodeAt(0);\n  const isPrintable = x => blankSpaceOrd <= x && x <= tildeOrd;\n  const isAsciiPrintable = program.every(x => x === lineBreakOrd || isPrintable(x));\n  if (isAsciiPrintable) {\n    const programStr = Buffer.from(program).toString();\n    if (isValidAddress(programStr)) throw new Error('requesting program bytes, get Algorand address');\n    if (Buffer.from(programStr, 'base64').toString('base64') === programStr) throw new Error('program should not be b64 encoded');\n    throw new Error('program bytes are all ASCII printable characters, not looking like Teal byte code');\n  }\n}\n/**\r\n LogicSig implementation\r\n\r\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\r\n */\nexport class LogicSig {\n  constructor(program, programArgs) {\n    this.tag = Buffer.from('Program');\n    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every(arg => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {\n      throw new TypeError('Invalid arguments');\n    }\n    let args;\n    if (programArgs != null) args = programArgs.map(arg => new Uint8Array(arg));\n    sanityCheckProgram(program);\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj = {\n      l: this.logic\n    };\n    if (this.args) {\n      obj.arg = this.args;\n    }\n    if (this.sig) {\n      obj.sig = this.sig;\n    } else if (this.msig) {\n      obj.msig = this.msig;\n    }\n    return obj;\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded) {\n    const lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n  /**\r\n   * Performs signature verification\r\n   * @param publicKey - Verification key (derived from sender address or escrow address)\r\n   */\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n    try {\n      sanityCheckProgram(this.logic);\n    } catch (e) {\n      return false;\n    }\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n    return verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n  /**\r\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\r\n   * @returns String representation of the address\r\n   */\n  address() {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(new Uint8Array(hash));\n  }\n  /**\r\n   * Creates signature (if no msig provided) or multi signature otherwise\r\n   * @param secretKey - Secret key to sign with\r\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\r\n   */\n  sign(secretKey, msig) {\n    if (msig == null) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = msig.addrs.map(addr => ({\n        pk: address.decodeAddress(addr).publicKey\n      }));\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs\n      };\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n  /**\r\n   * Appends a signature to multi signature\r\n   * @param secretKey - Secret key to sign with\r\n   */\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n  signProgram(secretKey) {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const {\n        pk\n      } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSig.from_obj_for_encoding(decodedObj);\n  }\n}\n/**\r\n * Represents an account that can sign with a LogicSig program.\r\n */\nexport class LogicSigAccount {\n  /**\r\n   * Create a new LogicSigAccount. By default this will create an escrow\r\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\r\n   * LogicSigAccount to make it a delegated account.\r\n   *\r\n   * @param program - The compiled TEAL program which contains the logic for\r\n   *   this LogicSig.\r\n   * @param args - An optional array of arguments for the program.\r\n   */\n  constructor(program, args) {\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj = {\n      lsig: this.lsig.get_obj_for_encoding()\n    };\n    if (this.sigkey) {\n      obj.sigkey = this.sigkey;\n    }\n    return obj;\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded) {\n    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);\n    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);\n    lsigAccount.sigkey = encoded.sigkey;\n    return lsigAccount;\n  }\n  /**\r\n   * Encode this object into msgpack.\r\n   */\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n  /**\r\n   * Decode a msgpack object into a LogicSigAccount.\r\n   * @param encoded - The encoded LogicSigAccount.\r\n   */\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSigAccount.from_obj_for_encoding(decodedObj);\n  }\n  /**\r\n   * Check if this LogicSigAccount has been delegated to another account with a\r\n   * signature.\r\n   *\r\n   * Note this function only checks for the presence of a delegation signature.\r\n   * To verify the delegation signature, use `verify`.\r\n   */\n  isDelegated() {\n    return !!(this.lsig.sig || this.lsig.msig);\n  }\n  /**\r\n   * Verifies this LogicSig's program and signatures.\r\n   * @returns true if and only if the LogicSig program and signatures are valid.\r\n   */\n  verify() {\n    const addr = this.address();\n    return this.lsig.verify(address.decodeAddress(addr).publicKey);\n  }\n  /**\r\n   * Get the address of this LogicSigAccount.\r\n   *\r\n   * If the LogicSig is delegated to another account, this will return the\r\n   * address of that account.\r\n   *\r\n   * If the LogicSig is not delegated to another account, this will return an\r\n   *  escrow address that is the hash of the LogicSig's program code.\r\n   */\n  address() {\n    if (this.lsig.sig && this.lsig.msig) {\n      throw new Error('LogicSig has too many signatures. At most one of sig or msig may be present');\n    }\n    if (this.lsig.sig) {\n      if (!this.sigkey) {\n        throw new Error('Signing key for delegated account is missing');\n      }\n      return address.encodeAddress(this.sigkey);\n    }\n    if (this.lsig.msig) {\n      const msigMetadata = {\n        version: this.lsig.msig.v,\n        threshold: this.lsig.msig.thr,\n        pks: this.lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      return address.encodeAddress(address.fromMultisigPreImg(msigMetadata));\n    }\n    return this.lsig.address();\n  }\n  /**\r\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\r\n   * has the authority to sign transactions on behalf of another account, called\r\n   * the delegating account. Use this function if the delegating account is a\r\n   * multisig account.\r\n   *\r\n   * @param msig - The multisig delegating account\r\n   * @param secretKey - The secret key of one of the members of the delegating\r\n   *   multisig account. Use `appendToMultisig` to add additional signatures\r\n   *   from other members.\r\n   */\n  signMultisig(msig, secretKey) {\n    this.lsig.sign(secretKey, msig);\n  }\n  /**\r\n   * Adds an additional signature from a member of the delegating multisig\r\n   * account.\r\n   *\r\n   * @param secretKey - The secret key of one of the members of the delegating\r\n   *   multisig account.\r\n   */\n  appendToMultisig(secretKey) {\n    this.lsig.appendToMultisig(secretKey);\n  }\n  /**\r\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\r\n   * has the authority to sign transactions on behalf of another account, called\r\n   * the delegating account. If the delegating account is a multisig account,\r\n   * use `signMultisig` instead.\r\n   *\r\n   * @param secretKey - The secret key of the delegating account.\r\n   */\n  sign(secretKey) {\n    this.lsig.sign(secretKey);\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n  }\n}\nfunction signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {\n  if (!lsig.verify(lsigAddress)) {\n    throw new Error('Logic signature verification failed. Ensure the program and signature are valid.');\n  }\n  const signedTxn = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding()\n  };\n  if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {\n    signedTxn.sgnr = Buffer.from(lsigAddress);\n  }\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(signedTxn)\n  };\n}\n/**\r\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\r\n * returns a signed transaction.\r\n *\r\n * @param txn - The transaction to sign.\r\n * @param lsigObject - The LogicSig object that will sign the transaction.\r\n *\r\n * @returns Object containing txID and blob representing signed transaction.\r\n */\nexport function signLogicSigTransactionObject(txn, lsigObject) {\n  let lsig;\n  let lsigAddress;\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = address.decodeAddress(lsigObject.address()).publicKey;\n  } else {\n    lsig = lsigObject;\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = txn.from.publicKey;\n    } else if (lsig.msig) {\n      const msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      lsigAddress = address.fromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = address.decodeAddress(lsig.address()).publicKey;\n    }\n  }\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n/**\r\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\r\n * a signed transaction.\r\n *\r\n * @param txn - The transaction to sign.\r\n * @param lsigObject - The LogicSig object that will sign the transaction.\r\n *\r\n * @returns Object containing txID and blob representing signed transaction.\r\n * @throws error on failure\r\n */\nexport function signLogicSigTransaction(txn, lsigObject) {\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return signLogicSigTransactionObject(algoTxn, lsigObject);\n}\n/**\r\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\r\n * returning the result\r\n */\nexport function logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n/**\r\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\r\n * @param sk - uint8array with secret key\r\n * @param data - buffer with data to sign\r\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\r\n */\nexport function tealSign(sk, data, programHash) {\n  const parts = utils.concatArrays(address.decodeAddress(programHash).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.sign(toBeSigned, sk);\n}\n/**\r\n * verifyTealSign verifies a signature as would the ed25519verify opcode\r\n * @param data - buffer with original signed data\r\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\r\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\r\n * @param pk - uint8array with public key to verify against\r\n */\nexport function verifyTealSign(data, programHash, sig, pk) {\n  const parts = utils.concatArrays(address.decodeAddress(programHash).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.verify(toBeSigned, sig, pk);\n}\n/**\r\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\r\n * @param sk - uint8array with secret key\r\n * @param data - buffer with data to sign\r\n * @param program - buffer with teal program\r\n */\nexport function tealSignFromProgram(sk, data, program) {\n  const lsig = new LogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","verifyMultisig","utils","txnBuilder","isValidAddress","sanityCheckProgram","program","length","Error","lineBreakOrd","charCodeAt","blankSpaceOrd","tildeOrd","isPrintable","x","isAsciiPrintable","every","programStr","from","toString","LogicSig","constructor","programArgs","tag","Array","isArray","arg","Uint8Array","isBuffer","TypeError","args","map","logic","sig","undefined","msig","get_obj_for_encoding","obj","l","from_obj_for_encoding","encoded","lsig","verify","publicKey","e","toBeSigned","concatArrays","hash","genericHash","arrayEqual","encodeAddress","sign","secretKey","signProgram","subsigs","addrs","addr","pk","decodeAddress","v","version","thr","threshold","subsig","index","singleSignMultisig","s","appendToMultisig","myPk","keyPairFromSecretKey","i","toByte","encode","fromByte","decodedObj","decode","LogicSigAccount","sigkey","lsigAccount","isDelegated","msigMetadata","pks","fromMultisigPreImg","signMultisig","signLogicSigTransactionWithAddress","txn","lsigAddress","signedTxn","bytesEqual","sgnr","txID","blob","signLogicSigTransactionObject","lsigObject","signLogicSigTransaction","algoTxn","instantiateTxnIfNeeded","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","data","programHash","parts","verifyTealSign","tealSignFromProgram","contractAddress"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\logicsig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport * as nacl from './nacl/naclWrappers';\r\nimport * as address from './encoding/address';\r\nimport * as encoding from './encoding/encoding';\r\nimport { verifyMultisig } from './multisig';\r\nimport * as utils from './utils/utils';\r\nimport * as txnBuilder from './transaction';\r\nimport { isValidAddress } from './encoding/address';\r\nimport {\r\n  EncodedLogicSig,\r\n  EncodedLogicSigAccount,\r\n  EncodedMultisig,\r\n  EncodedSignedTransaction,\r\n} from './types/transactions/encoded';\r\nimport { MultisigMetadata } from './types/multisig';\r\n\r\ninterface LogicSigStorageStructure {\r\n  logic: Uint8Array;\r\n  args: Uint8Array[];\r\n  sig?: Uint8Array;\r\n  msig?: EncodedMultisig;\r\n}\r\n\r\n/** sanityCheckProgram performs heuristic program validation:\r\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\r\n *\r\n * @param program - Program bytes to check\r\n */\r\nexport function sanityCheckProgram(program: Uint8Array) {\r\n  if (!program || program.length === 0) throw new Error('empty program');\r\n\r\n  const lineBreakOrd = '\\n'.charCodeAt(0);\r\n  const blankSpaceOrd = ' '.charCodeAt(0);\r\n  const tildeOrd = '~'.charCodeAt(0);\r\n\r\n  const isPrintable = (x: number) => blankSpaceOrd <= x && x <= tildeOrd;\r\n  const isAsciiPrintable = program.every(\r\n    (x: number) => x === lineBreakOrd || isPrintable(x)\r\n  );\r\n\r\n  if (isAsciiPrintable) {\r\n    const programStr = Buffer.from(program).toString();\r\n\r\n    if (isValidAddress(programStr))\r\n      throw new Error('requesting program bytes, get Algorand address');\r\n\r\n    if (Buffer.from(programStr, 'base64').toString('base64') === programStr)\r\n      throw new Error('program should not be b64 encoded');\r\n\r\n    throw new Error(\r\n      'program bytes are all ASCII printable characters, not looking like Teal byte code'\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n LogicSig implementation\r\n\r\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\r\n */\r\nexport class LogicSig implements LogicSigStorageStructure {\r\n  tag = Buffer.from('Program');\r\n\r\n  logic: Uint8Array;\r\n  args: Uint8Array[];\r\n  sig?: Uint8Array;\r\n  msig?: EncodedMultisig;\r\n\r\n  constructor(\r\n    program: Uint8Array,\r\n    programArgs?: Array<Uint8Array | Buffer> | null\r\n  ) {\r\n    if (\r\n      programArgs &&\r\n      (!Array.isArray(programArgs) ||\r\n        !programArgs.every(\r\n          (arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)\r\n        ))\r\n    ) {\r\n      throw new TypeError('Invalid arguments');\r\n    }\r\n\r\n    let args: Uint8Array[] | undefined;\r\n    if (programArgs != null)\r\n      args = programArgs.map((arg) => new Uint8Array(arg));\r\n\r\n    sanityCheckProgram(program);\r\n\r\n    this.logic = program;\r\n    this.args = args;\r\n    this.sig = undefined;\r\n    this.msig = undefined;\r\n  }\r\n\r\n  // eslint-disable-next-line camelcase\r\n  get_obj_for_encoding() {\r\n    const obj: EncodedLogicSig = {\r\n      l: this.logic,\r\n    };\r\n    if (this.args) {\r\n      obj.arg = this.args;\r\n    }\r\n    if (this.sig) {\r\n      obj.sig = this.sig;\r\n    } else if (this.msig) {\r\n      obj.msig = this.msig;\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  // eslint-disable-next-line camelcase\r\n  static from_obj_for_encoding(encoded: EncodedLogicSig) {\r\n    const lsig = new LogicSig(encoded.l, encoded.arg);\r\n    lsig.sig = encoded.sig;\r\n    lsig.msig = encoded.msig;\r\n    return lsig;\r\n  }\r\n\r\n  /**\r\n   * Performs signature verification\r\n   * @param publicKey - Verification key (derived from sender address or escrow address)\r\n   */\r\n  verify(publicKey: Uint8Array) {\r\n    if (this.sig && this.msig) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      sanityCheckProgram(this.logic);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\r\n\r\n    if (!this.sig && !this.msig) {\r\n      const hash = nacl.genericHash(toBeSigned);\r\n      return utils.arrayEqual(hash, publicKey);\r\n    }\r\n\r\n    if (this.sig) {\r\n      return nacl.verify(toBeSigned, this.sig, publicKey);\r\n    }\r\n\r\n    return verifyMultisig(toBeSigned, this.msig, publicKey);\r\n  }\r\n\r\n  /**\r\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\r\n   * @returns String representation of the address\r\n   */\r\n  address() {\r\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\r\n    const hash = nacl.genericHash(toBeSigned);\r\n    return address.encodeAddress(new Uint8Array(hash));\r\n  }\r\n\r\n  /**\r\n   * Creates signature (if no msig provided) or multi signature otherwise\r\n   * @param secretKey - Secret key to sign with\r\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\r\n   */\r\n  sign(secretKey: Uint8Array, msig?: MultisigMetadata) {\r\n    if (msig == null) {\r\n      this.sig = this.signProgram(secretKey);\r\n    } else {\r\n      const subsigs = msig.addrs.map((addr) => ({\r\n        pk: address.decodeAddress(addr).publicKey,\r\n      }));\r\n\r\n      this.msig = {\r\n        v: msig.version,\r\n        thr: msig.threshold,\r\n        subsig: subsigs,\r\n      };\r\n\r\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\r\n      this.msig.subsig[index].s = sig;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Appends a signature to multi signature\r\n   * @param secretKey - Secret key to sign with\r\n   */\r\n  appendToMultisig(secretKey: Uint8Array) {\r\n    if (this.msig === undefined) {\r\n      throw new Error('no multisig present');\r\n    }\r\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\r\n    this.msig.subsig[index].s = sig;\r\n  }\r\n\r\n  signProgram(secretKey: Uint8Array) {\r\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\r\n    const sig = nacl.sign(toBeSigned, secretKey);\r\n    return sig;\r\n  }\r\n\r\n  singleSignMultisig(\r\n    secretKey: Uint8Array,\r\n    msig: EncodedMultisig\r\n  ): [sig: Uint8Array, index: number] {\r\n    let index = -1;\r\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\r\n    for (let i = 0; i < msig.subsig.length; i++) {\r\n      const { pk } = msig.subsig[i];\r\n      if (utils.arrayEqual(pk, myPk)) {\r\n        index = i;\r\n        break;\r\n      }\r\n    }\r\n    if (index === -1) {\r\n      throw new Error('invalid secret key');\r\n    }\r\n    const sig = this.signProgram(secretKey);\r\n    return [sig, index];\r\n  }\r\n\r\n  toByte() {\r\n    return encoding.encode(this.get_obj_for_encoding());\r\n  }\r\n\r\n  static fromByte(encoded: ArrayLike<any>) {\r\n    const decodedObj = encoding.decode(encoded) as EncodedLogicSig;\r\n    return LogicSig.from_obj_for_encoding(decodedObj);\r\n  }\r\n}\r\n\r\n/**\r\n * Represents an account that can sign with a LogicSig program.\r\n */\r\nexport class LogicSigAccount {\r\n  lsig: LogicSig;\r\n  sigkey?: Uint8Array;\r\n\r\n  /**\r\n   * Create a new LogicSigAccount. By default this will create an escrow\r\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\r\n   * LogicSigAccount to make it a delegated account.\r\n   *\r\n   * @param program - The compiled TEAL program which contains the logic for\r\n   *   this LogicSig.\r\n   * @param args - An optional array of arguments for the program.\r\n   */\r\n  constructor(program: Uint8Array, args?: Array<Uint8Array | Buffer> | null) {\r\n    this.lsig = new LogicSig(program, args);\r\n    this.sigkey = undefined;\r\n  }\r\n\r\n  // eslint-disable-next-line camelcase\r\n  get_obj_for_encoding() {\r\n    const obj: EncodedLogicSigAccount = {\r\n      lsig: this.lsig.get_obj_for_encoding(),\r\n    };\r\n    if (this.sigkey) {\r\n      obj.sigkey = this.sigkey;\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  // eslint-disable-next-line camelcase\r\n  static from_obj_for_encoding(encoded: EncodedLogicSigAccount) {\r\n    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);\r\n    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);\r\n    lsigAccount.sigkey = encoded.sigkey;\r\n    return lsigAccount;\r\n  }\r\n\r\n  /**\r\n   * Encode this object into msgpack.\r\n   */\r\n  toByte() {\r\n    return encoding.encode(this.get_obj_for_encoding());\r\n  }\r\n\r\n  /**\r\n   * Decode a msgpack object into a LogicSigAccount.\r\n   * @param encoded - The encoded LogicSigAccount.\r\n   */\r\n  static fromByte(encoded: ArrayLike<any>) {\r\n    const decodedObj = encoding.decode(encoded) as EncodedLogicSigAccount;\r\n    return LogicSigAccount.from_obj_for_encoding(decodedObj);\r\n  }\r\n\r\n  /**\r\n   * Check if this LogicSigAccount has been delegated to another account with a\r\n   * signature.\r\n   *\r\n   * Note this function only checks for the presence of a delegation signature.\r\n   * To verify the delegation signature, use `verify`.\r\n   */\r\n  isDelegated() {\r\n    return !!(this.lsig.sig || this.lsig.msig);\r\n  }\r\n\r\n  /**\r\n   * Verifies this LogicSig's program and signatures.\r\n   * @returns true if and only if the LogicSig program and signatures are valid.\r\n   */\r\n  verify() {\r\n    const addr = this.address();\r\n    return this.lsig.verify(address.decodeAddress(addr).publicKey);\r\n  }\r\n\r\n  /**\r\n   * Get the address of this LogicSigAccount.\r\n   *\r\n   * If the LogicSig is delegated to another account, this will return the\r\n   * address of that account.\r\n   *\r\n   * If the LogicSig is not delegated to another account, this will return an\r\n   *  escrow address that is the hash of the LogicSig's program code.\r\n   */\r\n  address() {\r\n    if (this.lsig.sig && this.lsig.msig) {\r\n      throw new Error(\r\n        'LogicSig has too many signatures. At most one of sig or msig may be present'\r\n      );\r\n    }\r\n\r\n    if (this.lsig.sig) {\r\n      if (!this.sigkey) {\r\n        throw new Error('Signing key for delegated account is missing');\r\n      }\r\n      return address.encodeAddress(this.sigkey);\r\n    }\r\n\r\n    if (this.lsig.msig) {\r\n      const msigMetadata = {\r\n        version: this.lsig.msig.v,\r\n        threshold: this.lsig.msig.thr,\r\n        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk),\r\n      };\r\n      return address.encodeAddress(address.fromMultisigPreImg(msigMetadata));\r\n    }\r\n\r\n    return this.lsig.address();\r\n  }\r\n\r\n  /**\r\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\r\n   * has the authority to sign transactions on behalf of another account, called\r\n   * the delegating account. Use this function if the delegating account is a\r\n   * multisig account.\r\n   *\r\n   * @param msig - The multisig delegating account\r\n   * @param secretKey - The secret key of one of the members of the delegating\r\n   *   multisig account. Use `appendToMultisig` to add additional signatures\r\n   *   from other members.\r\n   */\r\n  signMultisig(msig: MultisigMetadata, secretKey: Uint8Array) {\r\n    this.lsig.sign(secretKey, msig);\r\n  }\r\n\r\n  /**\r\n   * Adds an additional signature from a member of the delegating multisig\r\n   * account.\r\n   *\r\n   * @param secretKey - The secret key of one of the members of the delegating\r\n   *   multisig account.\r\n   */\r\n  appendToMultisig(secretKey: Uint8Array) {\r\n    this.lsig.appendToMultisig(secretKey);\r\n  }\r\n\r\n  /**\r\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\r\n   * has the authority to sign transactions on behalf of another account, called\r\n   * the delegating account. If the delegating account is a multisig account,\r\n   * use `signMultisig` instead.\r\n   *\r\n   * @param secretKey - The secret key of the delegating account.\r\n   */\r\n  sign(secretKey: Uint8Array) {\r\n    this.lsig.sign(secretKey);\r\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\r\n  }\r\n}\r\n\r\nfunction signLogicSigTransactionWithAddress(\r\n  txn: txnBuilder.Transaction,\r\n  lsig: LogicSig,\r\n  lsigAddress: Uint8Array\r\n) {\r\n  if (!lsig.verify(lsigAddress)) {\r\n    throw new Error(\r\n      'Logic signature verification failed. Ensure the program and signature are valid.'\r\n    );\r\n  }\r\n\r\n  const signedTxn: EncodedSignedTransaction = {\r\n    lsig: lsig.get_obj_for_encoding(),\r\n    txn: txn.get_obj_for_encoding(),\r\n  };\r\n\r\n  if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {\r\n    signedTxn.sgnr = Buffer.from(lsigAddress);\r\n  }\r\n\r\n  return {\r\n    txID: txn.txID().toString(),\r\n    blob: encoding.encode(signedTxn),\r\n  };\r\n}\r\n\r\n/**\r\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\r\n * returns a signed transaction.\r\n *\r\n * @param txn - The transaction to sign.\r\n * @param lsigObject - The LogicSig object that will sign the transaction.\r\n *\r\n * @returns Object containing txID and blob representing signed transaction.\r\n */\r\nexport function signLogicSigTransactionObject(\r\n  txn: txnBuilder.Transaction,\r\n  lsigObject: LogicSig | LogicSigAccount\r\n) {\r\n  let lsig: LogicSig;\r\n  let lsigAddress: Uint8Array;\r\n\r\n  if (lsigObject instanceof LogicSigAccount) {\r\n    lsig = lsigObject.lsig;\r\n    lsigAddress = address.decodeAddress(lsigObject.address()).publicKey;\r\n  } else {\r\n    lsig = lsigObject;\r\n\r\n    if (lsig.sig) {\r\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\r\n      // the address of that account from only its signature, so assume the\r\n      // delegating account is the sender. If that's not the case, the signing\r\n      // will fail.\r\n      lsigAddress = txn.from.publicKey;\r\n    } else if (lsig.msig) {\r\n      const msigMetadata = {\r\n        version: lsig.msig.v,\r\n        threshold: lsig.msig.thr,\r\n        pks: lsig.msig.subsig.map((subsig) => subsig.pk),\r\n      };\r\n      lsigAddress = address.fromMultisigPreImg(msigMetadata);\r\n    } else {\r\n      lsigAddress = address.decodeAddress(lsig.address()).publicKey;\r\n    }\r\n  }\r\n\r\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\r\n}\r\n\r\n/**\r\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\r\n * a signed transaction.\r\n *\r\n * @param txn - The transaction to sign.\r\n * @param lsigObject - The LogicSig object that will sign the transaction.\r\n *\r\n * @returns Object containing txID and blob representing signed transaction.\r\n * @throws error on failure\r\n */\r\nexport function signLogicSigTransaction(\r\n  txn: txnBuilder.TransactionLike,\r\n  lsigObject: LogicSig | LogicSigAccount\r\n) {\r\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\r\n  return signLogicSigTransactionObject(algoTxn, lsigObject);\r\n}\r\n\r\n/**\r\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\r\n * returning the result\r\n */\r\nexport function logicSigFromByte(encoded: Uint8Array) {\r\n  return LogicSig.fromByte(encoded);\r\n}\r\n\r\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\r\n\r\n/**\r\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\r\n * @param sk - uint8array with secret key\r\n * @param data - buffer with data to sign\r\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\r\n */\r\nexport function tealSign(\r\n  sk: Uint8Array,\r\n  data: Uint8Array | Buffer,\r\n  programHash: string\r\n) {\r\n  const parts = utils.concatArrays(\r\n    address.decodeAddress(programHash).publicKey,\r\n    data\r\n  );\r\n  const toBeSigned = Buffer.from(\r\n    utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts)\r\n  );\r\n  return nacl.sign(toBeSigned, sk);\r\n}\r\n\r\n/**\r\n * verifyTealSign verifies a signature as would the ed25519verify opcode\r\n * @param data - buffer with original signed data\r\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\r\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\r\n * @param pk - uint8array with public key to verify against\r\n */\r\nexport function verifyTealSign(\r\n  data: Uint8Array | Buffer,\r\n  programHash: string,\r\n  sig: Uint8Array,\r\n  pk: Uint8Array\r\n) {\r\n  const parts = utils.concatArrays(\r\n    address.decodeAddress(programHash).publicKey,\r\n    data\r\n  );\r\n  const toBeSigned = Buffer.from(\r\n    utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts)\r\n  );\r\n  return nacl.verify(toBeSigned, sig, pk);\r\n}\r\n\r\n/**\r\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\r\n * @param sk - uint8array with secret key\r\n * @param data - buffer with data to sign\r\n * @param program - buffer with teal program\r\n */\r\nexport function tealSignFromProgram(\r\n  sk: Uint8Array,\r\n  data: Uint8Array | Buffer,\r\n  program: Uint8Array\r\n) {\r\n  const lsig = new LogicSig(program);\r\n  const contractAddress = lsig.address();\r\n  return tealSign(sk, data, contractAddress);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}