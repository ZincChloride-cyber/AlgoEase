{"ast":null,"code":"import { genericHash } from '../nacl/naclWrappers';\nimport { ABIType, ABITupleType } from './abi_type';\nimport { abiTypeIsTransaction } from './transaction';\nimport { abiTypeIsReference } from './reference';\nfunction parseMethodSignature(signature) {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n  if (argsEnd === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),\n    returns: signature.slice(argsEnd + 1)\n  };\n}\nexport class ABIMethod {\n  constructor(params) {\n    if (typeof params.name !== 'string' || typeof params.returns !== 'object' || !Array.isArray(params.args)) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(({\n      type,\n      name,\n      desc\n    }) => {\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc\n        };\n      }\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc\n      };\n    });\n    this.returns = {\n      type: params.returns.type === 'void' ? params.returns.type : ABIType.from(params.returns.type),\n      description: params.returns.desc\n    };\n    this.events = params.events;\n    this.readonly = params.readonly;\n  }\n  getSignature() {\n    const args = this.args.map(arg => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return `${this.name}(${args})${returns}`;\n  }\n  getSelector() {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n  txnCount() {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(({\n        type,\n        name,\n        description\n      }) => ({\n        type: type.toString(),\n        name,\n        desc: description\n      })),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description\n      },\n      events: this.events,\n      readonly: this.readonly\n    };\n  }\n  static fromSignature(signature) {\n    const {\n      name,\n      args,\n      returns\n    } = parseMethodSignature(signature);\n    return new ABIMethod({\n      name,\n      args: args.map(arg => ({\n        type: arg\n      })),\n      returns: {\n        type: returns\n      }\n    });\n  }\n}\nexport function getMethodByName(methods, name) {\n  if (methods === null || !Array.isArray(methods) || !methods.every(item => item instanceof ABIMethod)) throw new Error('Methods list provided is null or not the correct type');\n  const filteredMethods = methods.filter(m => m.name === name);\n  if (filteredMethods.length > 1) throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map(m => m.getSignature()).join(',')}`);\n  if (filteredMethods.length === 0) throw new Error(`found 0 methods with the name ${name}`);\n  return filteredMethods[0];\n}","map":{"version":3,"names":["genericHash","ABIType","ABITupleType","abiTypeIsTransaction","abiTypeIsReference","parseMethodSignature","signature","argsStart","indexOf","Error","argsEnd","depth","i","length","char","name","slice","args","parseTupleContent","returns","ABIMethod","constructor","params","Array","isArray","description","desc","map","type","from","events","readonly","getSignature","arg","toString","join","getSelector","hash","Uint8Array","txnCount","count","toJSON","fromSignature","getMethodByName","methods","every","item","filteredMethods","filter","m"],"sources":["C:\\Users\\Aditya singh\\AlgoEase\\frontend\\node_modules\\algosdk\\src\\abi\\method.ts"],"sourcesContent":["import { genericHash } from '../nacl/naclWrappers';\r\nimport { ABIType, ABITupleType } from './abi_type';\r\nimport { ABITransactionType, abiTypeIsTransaction } from './transaction';\r\nimport { ABIReferenceType, abiTypeIsReference } from './reference';\r\nimport { ARC28Event } from './event';\r\n\r\nfunction parseMethodSignature(\r\n  signature: string\r\n): { name: string; args: string[]; returns: string } {\r\n  const argsStart = signature.indexOf('(');\r\n  if (argsStart === -1) {\r\n    throw new Error(`Invalid method signature: ${signature}`);\r\n  }\r\n\r\n  let argsEnd = -1;\r\n  let depth = 0;\r\n  for (let i = argsStart; i < signature.length; i++) {\r\n    const char = signature[i];\r\n\r\n    if (char === '(') {\r\n      depth += 1;\r\n    } else if (char === ')') {\r\n      if (depth === 0) {\r\n        // unpaired parenthesis\r\n        break;\r\n      }\r\n\r\n      depth -= 1;\r\n      if (depth === 0) {\r\n        argsEnd = i;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (argsEnd === -1) {\r\n    throw new Error(`Invalid method signature: ${signature}`);\r\n  }\r\n\r\n  return {\r\n    name: signature.slice(0, argsStart),\r\n    args: ABITupleType.parseTupleContent(\r\n      signature.slice(argsStart + 1, argsEnd)\r\n    ),\r\n    returns: signature.slice(argsEnd + 1),\r\n  };\r\n}\r\n\r\nexport interface ABIMethodArgParams {\r\n  type: string;\r\n  name?: string;\r\n  desc?: string;\r\n}\r\n\r\nexport interface ABIMethodReturnParams {\r\n  type: string;\r\n  desc?: string;\r\n}\r\n\r\nexport interface ABIMethodParams {\r\n  name: string;\r\n  desc?: string;\r\n  args: ABIMethodArgParams[];\r\n  returns: ABIMethodReturnParams;\r\n  /** Optional, is it a read-only method (according to [ARC-22](https://arc.algorand.foundation/ARCs/arc-0022)) */\r\n  readonly?: boolean;\r\n  /** [ARC-28](https://arc.algorand.foundation/ARCs/arc-0028) events that MAY be emitted by this method */\r\n  events?: ARC28Event[];\r\n}\r\n\r\nexport type ABIArgumentType = ABIType | ABITransactionType | ABIReferenceType;\r\n\r\nexport type ABIReturnType = ABIType | 'void';\r\n\r\nexport class ABIMethod {\r\n  public readonly name: string;\r\n  public readonly description?: string;\r\n  public readonly args: Array<{\r\n    type: ABIArgumentType;\r\n    name?: string;\r\n    description?: string;\r\n  }>;\r\n\r\n  public readonly returns: { type: ABIReturnType; description?: string };\r\n  public readonly events?: ARC28Event[];\r\n  public readonly readonly?: boolean;\r\n\r\n  constructor(params: ABIMethodParams) {\r\n    if (\r\n      typeof params.name !== 'string' ||\r\n      typeof params.returns !== 'object' ||\r\n      !Array.isArray(params.args)\r\n    ) {\r\n      throw new Error('Invalid ABIMethod parameters');\r\n    }\r\n\r\n    this.name = params.name;\r\n    this.description = params.desc;\r\n    this.args = params.args.map(({ type, name, desc }) => {\r\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\r\n        return {\r\n          type,\r\n          name,\r\n          description: desc,\r\n        };\r\n      }\r\n\r\n      return {\r\n        type: ABIType.from(type),\r\n        name,\r\n        description: desc,\r\n      };\r\n    });\r\n    this.returns = {\r\n      type:\r\n        params.returns.type === 'void'\r\n          ? params.returns.type\r\n          : ABIType.from(params.returns.type),\r\n      description: params.returns.desc,\r\n    };\r\n\r\n    this.events = params.events;\r\n    this.readonly = params.readonly;\r\n  }\r\n\r\n  getSignature(): string {\r\n    const args = this.args.map((arg) => arg.type.toString()).join(',');\r\n    const returns = this.returns.type.toString();\r\n    return `${this.name}(${args})${returns}`;\r\n  }\r\n\r\n  getSelector(): Uint8Array {\r\n    const hash = genericHash(this.getSignature());\r\n    return new Uint8Array(hash.slice(0, 4));\r\n  }\r\n\r\n  txnCount(): number {\r\n    let count = 1;\r\n    for (const arg of this.args) {\r\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\r\n        count += 1;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  toJSON(): ABIMethodParams {\r\n    return {\r\n      name: this.name,\r\n      desc: this.description,\r\n      args: this.args.map(({ type, name, description }) => ({\r\n        type: type.toString(),\r\n        name,\r\n        desc: description,\r\n      })),\r\n      returns: {\r\n        type: this.returns.type.toString(),\r\n        desc: this.returns.description,\r\n      },\r\n      events: this.events,\r\n      readonly: this.readonly,\r\n    };\r\n  }\r\n\r\n  static fromSignature(signature: string): ABIMethod {\r\n    const { name, args, returns } = parseMethodSignature(signature);\r\n\r\n    return new ABIMethod({\r\n      name,\r\n      args: args.map((arg) => ({ type: arg })),\r\n      returns: { type: returns },\r\n    });\r\n  }\r\n}\r\n\r\nexport function getMethodByName(methods: ABIMethod[], name: string): ABIMethod {\r\n  if (\r\n    methods === null ||\r\n    !Array.isArray(methods) ||\r\n    !methods.every((item) => item instanceof ABIMethod)\r\n  )\r\n    throw new Error('Methods list provided is null or not the correct type');\r\n\r\n  const filteredMethods = methods.filter((m: ABIMethod) => m.name === name);\r\n  if (filteredMethods.length > 1)\r\n    throw new Error(\r\n      `found ${\r\n        filteredMethods.length\r\n      } methods with the same name ${filteredMethods\r\n        .map((m: ABIMethod) => m.getSignature())\r\n        .join(',')}`\r\n    );\r\n\r\n  if (filteredMethods.length === 0)\r\n    throw new Error(`found 0 methods with the name ${name}`);\r\n\r\n  return filteredMethods[0];\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}